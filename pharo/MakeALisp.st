Object subclass: #Mal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!Mal commentStamp: 'WilfredHughes 6/5/2019 00:51' prior: 0!I am a Make-A-Lisp (MAL) interpreter.You can use me from a CLI (see MalStep) or see:  Mal demo.for an example of running.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mal class	instanceVariableNames: ''!!Mal class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 00:50'!eval: aForm in: ctx	^ aForm evalIn: ctx! !!Mal class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 00:50'!demo	| val |	val := Mal read: '(/ (+ 5 6) 2)'.	^ val evalIn: MalContext default! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/5/2019 09:52'!rep: aString	^ self rep: aString in: MalContext default! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/23/2019 16:12'!prelude	^ '(do (def!! not (fn* (a) (if a false true)))(def!! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\n)")))))(defmacro!! cond  (fn* (& xs)       (if (> (count xs) 0)           (list ''if                 (first xs)                 (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond"))                 (cons ''cond (rest (rest xs)))))))(def!! *host-language* "pharo")(def!! inc (fn* [x] (+ x 1)))(def!! gensym (let* [counter (atom 0)] (fn* [] (symbol (str "G__" (swap!! counter inc))))))(defmacro!! or  (fn* (& xs)       (if (empty? xs)           nil         (if (= 1 (count xs))             (first xs)           (let* (condvar (gensym))             `(let* (~condvar ~(first xs))                (if ~condvar ~condvar (or ~@(rest xs)))))))))	)'! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!Mal class methodsFor: 'printing' stamp: 'WilfredHughes 6/4/2019 00:36'!print: aValue	^ aValue asReadableString! !!Mal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 5/14/2019 10:01'!read: aString	^ MalReader readString: aString! !Object subclass: #MalContext	instanceVariableNames: 'env stdout'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalContext commentStamp: 'WilfredHughes 6/2/2019 20:39' prior: 0!I represent the state needed to evaluate MAL expressions.To evaluate MAl programs with a full environment use:MalContext default.!!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!env	^ env! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!stdout	^ stdout! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!stdout: anObject	stdout := anObject! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:39'!env: bindings	env := bindings! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:40'!withEnv: newEnv"Return a copy of self with a different environment."	^ self class		new		env: newEnv;		stdout: stdout;		yourself! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 6/5/2019 09:49'!globalEnv	| result |	result := env.	[ result outer isNotNil  ] whileTrue: [ result := result outer ].   ^ result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalContext class	instanceVariableNames: ''!!MalContext class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 20:43'!default	"Initialise the MAL context with a full environment."	| ctx |	ctx := self new		env: MalEnv default;		yourself.	(Mal read: (Mal prelude)) evalIn: ctx .	^ ctx! !Object subclass: #MalEnv	instanceVariableNames: 'bindings outer stdout'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEnv commentStamp: 'WilfredHughes 5/22/2019 10:28' prior: 0!I represent environments in MAL. I look up symbols, and can defer toouter environments if a symbol isn't present in my bindings.My API roughly follows Dictionary.I also hold references to Smalltalk objects that MAL needs, such as stdout.!!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:05'!at: aSymbol ifPresent: presentBlock ifAbsent: absentBlock	| key |	key := aSymbol value.	^ bindings		at: key		ifPresent: [ :value | ^ presentBlock cull: value ]		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifPresent: presentBlock ifAbsent: absentBlock ]				ifNil: [ absentBlock value ] ]! !!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:12'!at: aSymbol	| key |	self		assert: [ aSymbol class = MalSymbol ]		description: 'env keys should be symbols'.	key := aSymbol value.	^ self		at: key		ifAbsent: [ MalUnboundSymbol signal: 'Unbound variable: ' , key ]! !!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:05'!at: aSymbol ifAbsent: aBlock	| key |	key := aSymbol value.	^ bindings		at: key		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifAbsent: aBlock ]				ifNil: [ aBlock value ] ]! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:56'!bindings: aDictionary	bindings := aDictionary! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:57'!outer: aLinkedDictionary	outer := aLinkedDictionary! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/22/2019 10:12'!at: aSymbol put: value	"Insert this symbol at this level"	| key |		self		assert: [ aSymbol class = MalSymbol ]		description: 'env keys should be symbols'.	key := aSymbol value.	bindings at: key put: value! !!MalEnv methodsFor: 'accessing' stamp: 'WilfredHughes 6/5/2019 09:47'!outer	^ outer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEnv class	instanceVariableNames: ''!!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/25/2019 11:57'!withOuter: env	self		assert: [ env class = self ]		description: [ 'Outer env class should match this env' ].	^ self new		outer: env;		yourself! !!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/8/2019 10:08'!new	^ super new		bindings: Dictionary new;		yourself! !!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/25/2019 13:42'!default	| env |	env := self new.	MalFunction allSubclassesDo: [ :func | env at: (MalSymbol withValue: func malName) put: func new ].	^ env		! !Error subclass: #MalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!Object subclass: #MalLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLiteral commentStamp: 'WilfredHughes 5/25/2019 13:46' prior: 0!I represent atoms in MAL. My subclasses can convert lexemes (a string) to a MAL value.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLiteral class	instanceVariableNames: ''!!MalLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 14:09'!fromToken: token	self subclassResponsibility! !!MalLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 13:49'!matches: aStringself subclassResponsibility ! !MalLiteral subclass: #MalBoolLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalBoolLiteral commentStamp: 'WilfredHughes 5/25/2019 13:47' prior: 0!I convert true and false strings to MAL values.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalBoolLiteral class	instanceVariableNames: ''!!MalBoolLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 13:56'!fromToken: aString	aString = 'true' ifTrue: [ ^ MalBool withValue: true ] ifFalse: [ ^MalBool withValue: false ]! !!MalBoolLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 13:55'!matches: aString	^ (aString = 'true') | (aString = 'false')! !MalLiteral subclass: #MalKeywordLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeywordLiteral commentStamp: 'WilfredHughes 6/2/2019 20:01' prior: 0!I convert strings ':foo' into MalKeyword values.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalKeywordLiteral class	instanceVariableNames: ''!!MalKeywordLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 6/2/2019 20:02'!fromToken: aString	^ MalKeyword withValue: aString! !!MalKeywordLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 6/2/2019 20:02'!matches: aString	^ aString first = $:! !MalLiteral subclass: #MalNilLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNilLiteral commentStamp: 'WilfredHughes 5/29/2019 10:37' prior: 0!I convert the string 'nil' to the MAL nil value.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNilLiteral class	instanceVariableNames: ''!!MalNilLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 10:38'!fromToken: aString	^ MalNil new! !!MalNilLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 10:37'!matches: aString	^ aString = 'nil'! !MalError subclass: #MalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!MalLiteral subclass: #MalNumberLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNumberLiteral commentStamp: 'WilfredHughes 5/25/2019 14:06' prior: 0!I convert number literals to number values in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNumberLiteral class	instanceVariableNames: ''!!MalNumberLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 14:10'!fromToken: token	^ MalInteger withValue: token asInteger! !!MalNumberLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 14:13'!matches: token	^ token isAllDigits		| (token first = $- & token allButFirst isAllDigits)! !Object subclass: #MalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReader commentStamp: 'WilfredHughes 5/29/2019 23:00' prior: 0!I convert MAL source code to an AST instance of MalType.I return an OrderedCollection of forms read.To get started, use #readString:MalReader readString: '(+ 1 2)'.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReader class	instanceVariableNames: ''!!MalReader class methodsFor: 'parsing' stamp: 'WilfredHughes 6/17/2019 09:47'!readList: aTokenStream withClose: delimiter	| items current finished |	items := OrderedCollection new.	finished := false.	"Always initialised, but the browser can't see that the 	loop is executed at least once.."	current := nil.	[ finished ]		whileFalse: [ current := aTokenStream peek.			(self isClose: current expected: delimiter)				ifTrue: [ finished := true.					aTokenStream next ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	(self isClose: current expected: delimiter)		ifFalse: [ MalError signal: 'Unclosed ( [ or {' ].	delimiter = ']'		ifTrue: [ ^ MalVector withValue: items ].	delimiter = '}'		ifTrue: [ ^ MalHashMap withItems: items ].	^ MalList withValue: items! !!MalReader class methodsFor: 'parsing' stamp: 'WilfredHughes 6/25/2019 09:36'!readForm: aTokenStream	| current readerMacros |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream withClose: ')' ].	current = '['		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream withClose: ']' ].	current = '{'		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream withClose: '}' ].	readerMacros := Dictionary		with: '@' -> 'deref'		with: '''' -> 'quote'		with: '`' -> 'quasiquote'		with: '~' -> 'unquote'		with: '~@' -> 'splice-unquote'		with: '^' -> 'with-meta'.	readerMacros		at: current		ifPresent: [ :symName | 			aTokenStream next.			symName = 'with-meta' ifTrue: [ MalList				with: (MalSymbol withValue: symName)				with: (self readForm: aTokenStream)				with: (self readForm: aTokenStream) ].			^ MalList				with: (MalSymbol withValue: symName)				with: (self readForm: aTokenStream) ].	^ self readAtom: aTokenStream! !!MalReader class methodsFor: 'parsing' stamp: 'WilfredHughes 5/31/2019 00:07'!readAtom: aStream	"Parse a single mal type."	| token firstChar |	token := aStream next.	token ifNil: [ MalSyntaxError signal: 'Missing ) ] or }' ].	firstChar := token first: 1.	(self isClose: token)		ifTrue: [ MalSyntaxError signal: 'Unexpected ) ] or }' ].	MalLiteral		allSubclassesDo: [ :atom | 			(atom matches: token)				ifTrue: [ ^ atom fromToken: token ] ].	^ MalSymbol withValue: token! !!MalReader class methodsFor: 'parsing' stamp: 'WilfredHughes 5/31/2019 00:06'!isClose: aString	^ (#(')' ']' '}') includes: aString)! !!MalReader class methodsFor: 'parsing' stamp: 'WilfredHughes 5/31/2019 00:06'!isClose: aString expected: close	(self isClose: aString)		ifFalse: [ ^ false ].	aString = close		ifFalse: [ MalSyntaxError signal: 'wrong closing paren character' ].	^ true! !!MalReader class methodsFor: 'parsing' stamp: 'WilfredHughes 6/17/2019 09:45'!readString: aString	"Lex and parse a string of MAL source code."	| tokens stream |	tokens := MalTokenizer fromString: aString.	stream := tokens readStream.	^ self readForm: stream! !Object subclass: #MalSpecialForm	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSpecialForm commentStamp: 'WilfredHughes 5/19/2019 12:13' prior: 0!I represent special forms in MAL.Special forms choose whether to evaluate their arguments, and cannot be shadowed by variables.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSpecialForm class	instanceVariableNames: ''!!MalSpecialForm class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 20:50'!call: args withContext: ctx	self subclassResponsibility! !!MalSpecialForm class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 00:38'!matchesSymbol: aSymbol	self		subclassesDo: [ :f | 			f malName = aSymbol value				ifTrue: [ ^ f ] ].	^ nil! !!MalSpecialForm class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:30'!malNameself subclassResponsibility ! !MalSpecialForm subclass: #MalDef	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDef commentStamp: 'WilfredHughes 5/19/2019 12:42' prior: 0!I represent the def!! special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDef class	instanceVariableNames: ''!!MalDef class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:42'!malName	^ 'def!!'! !!MalDef class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 09:49'!call: args withContext: ctx	| sym val |	args size = 2		ifFalse: [ MalWrongArity				signal: ('def!! requires 2 arguments (got {1}' format: {args size}) ].	sym := args first.	sym class = MalSymbol		ifFalse: [ MalError signal: 'The first argument to def!! must be a symbol' ].	val := args second evalIn: ctx.	ctx globalEnv at: sym put: val.	^ val! !MalSpecialForm subclass: #MalDefmacro	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDefmacro commentStamp: 'WilfredHughes 6/13/2019 10:02' prior: 0!I represent the defmacro!! special form.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDefmacro class	instanceVariableNames: ''!!MalDefmacro class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 15:39'!call: args withContext: ctx	| sym val |	args size = 2		ifFalse: [ MalWrongArity				signal: ('defmacro!! requires 2 arguments (got {1}' format: {args size}) ].	sym := args first.	sym class = MalSymbol		ifFalse: [ MalError signal: 'The first argument to def!! must be a symbol' ].	val := args second evalIn: ctx.	"Ensure we don't modify the original function."	val := val copy.	val isMacro: true.	ctx globalEnv at: sym put: val.	^ val! !!MalDefmacro class methodsFor: 'accessing' stamp: 'WilfredHughes 6/11/2019 10:05'!malName	^ 'defmacro!!'! !MalSpecialForm subclass: #MalDo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDo commentStamp: 'WilfredHughes 5/19/2019 12:40' prior: 0!I represent the do special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDo class	instanceVariableNames: ''!!MalDo class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:40'!malName	^ 'do'! !!MalDo class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 12:25'!call: args withContext: ctx	| result |	result := nil.	args do: [ :expr | result := expr evalIn: ctx ].	^ result! !MalSpecialForm subclass: #MalFn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFn commentStamp: 'WilfredHughes 5/20/2019 09:57' prior: 0!I represent the fn* special form, and create a MalClosure.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFn class	instanceVariableNames: ''!!MalFn class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/13/2019 19:30'!call: args withContext: ctx	| wrappedParams params body variadicSym |	args isEmpty		ifTrue: [ MalWrongArity signal: 'fn* requires a list of parameters' ].	wrappedParams := args first.	wrappedParams isIterable		ifFalse: [ MalError signal: 'fn* parameters must be iterable' ].	params := wrappedParams value.	variadicSym := nil.	params		doWithIndex: [ :param :i | 			param class = MalSymbol				ifFalse: [ MalError signal: 'fn* parameters must be symbols: ' , param asReadableString  ].			param value = '&'				ifTrue: [ i = (params size - 1)						ifFalse: [ MalError signal: '& must be in the penultimate position' ].					variadicSym := params last ] ].	variadicSym isNotNil		ifTrue: [ params := params allButLast: 2 ].	body := args allButFirst.	^ MalClosure new		env: ctx env;		bindings: params;		variadicSym: variadicSym;		body: body;		isMacro: false;		yourself! !!MalFn class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 09:57'!malName	^ 'fn*'! !MalSpecialForm subclass: #MalIf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalIf commentStamp: 'WilfredHughes 5/19/2019 12:33' prior: 0!I represent the if special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalIf class	instanceVariableNames: ''!!MalIf class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 13:30'!call: args withContext: ctx	| condition result |	args size < 2		ifTrue: [ MalWrongArity signal: 'if requires at least two arguments' ].	condition := args first evalIn: ctx.	condition isTruthy		ifTrue: [ ^ args second evalIn: ctx ].	result := MalNil new.	(args allButFirst: 2) do: [ :arg | result := arg evalIn: ctx ].	^ result! !!MalIf class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:33'!malName	^ 'if'! !MalSpecialForm subclass: #MalLet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLet commentStamp: 'WilfredHughes 5/20/2019 00:33' prior: 0!I represent let* in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLet class	instanceVariableNames: ''!!MalLet class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 00:34'!malName	^ 'let*'! !!MalLet class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 20:31'!call: args withContext: ctx	| newEnv bindings result newCtx |	args isEmpty		ifTrue: [ MalWrongArity signal: 'let* requires a list of bindings' ].	newEnv := MalEnv withOuter: ctx env.	newCtx := ctx withEnv: newEnv.	bindings := args first.	({ MalList. MalVector } includes: (bindings class))		ifFalse: [ MalError signal: 'let* requires a list of bindings' ].	(bindings value size isDivisibleBy: 2)		ifFalse: [ MalError signal: 'let* requires an even number of bindings' ].	bindings value		withIndexDo: [ :b :i | 			(i isDivisibleBy: 2)				ifFalse: [ b class = MalSymbol						ifFalse: [ MalError signal: 'Expected a symbol for let binding' ] ] ].	bindings value		pairsDo: [ :var :rawVal | 			| val |			val := rawVal evalIn: newCtx.			newCtx env at: var put: val ].	result := nil.	args allButFirst do: [ :expr | result := expr evalIn: newCtx ].	^ result! !MalSpecialForm subclass: #MalMacroexpand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMacroexpand commentStamp: 'WilfredHughes 6/15/2019 20:49' prior: 0!I represent the macroexpand special form exposed to the user.For internal macro expansion logic, see implementors of macroexpandIn:.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMacroexpand class	instanceVariableNames: ''!!MalMacroexpand class methodsFor: 'accessing' stamp: 'WilfredHughes 6/13/2019 10:19'!malName	^ 'macroexpand'! !!MalMacroexpand class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 21:49'!call: args withContext: ctx	args size = 1		ifFalse: [ MalWrongArity signal: 'macroexpand takes one argument' ].	^ args first macroexpandAllIn: ctx! !MalSpecialForm subclass: #MalQuasiquote	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalQuasiquote commentStamp: 'WilfredHughes 6/6/2019 10:22' prior: 0!I represent the quasiquote special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalQuasiquote class	instanceVariableNames: ''!!MalQuasiquote class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/7/2019 21:41'!call: args withContext: ctx	| arg |	args size = 1		ifFalse: [ MalWrongArity				signal: ('quasiquote requires 1 argument (got {1})' format: {args size}) ].	arg := args first.	^ (self unquote: arg) evalIn: ctx! !!MalQuasiquote class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 10:29'!unquote: ast	"Rewrite quasiquoted expr as a series of calls to concat with quoted expressions.	`foo -> 'foo	`(x ~@y z) -> (concat 'x value-of-y 'z)"	| head |	ast isPair		ifFalse: [ ^ MalList with: (MalSymbol withValue: 'quote') with: ast ].	head := ast value first.	head = (MalSymbol withValue: 'unquote')		ifTrue: [ ^ ast value second ].	"((~@foo) x y) -> (concat foo 'x 'y)"	head isPair		ifTrue: [ head value first = (MalSymbol withValue: 'splice-unquote')				ifTrue: [ ^ MalList						with: (MalSymbol withValue: 'concat')						with: head value second						with: (self unquote: ast allButFirst) ] ].	^ MalList				with: (MalSymbol withValue: 'cons')				with: (self unquote: ast value first)				with: (self unquote: ast allButFirst)! !!MalQuasiquote class methodsFor: 'accessing' stamp: 'WilfredHughes 6/6/2019 10:22'!malName	^ 'quasiquote'! !MalSpecialForm subclass: #MalQuote	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalQuote commentStamp: 'WilfredHughes 6/6/2019 10:17' prior: 0!I represent the quote special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalQuote class	instanceVariableNames: ''!!MalQuote class methodsFor: 'accessing' stamp: 'WilfredHughes 6/6/2019 10:21'!malName	^ 'quote'! !!MalQuote class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/6/2019 10:22'!call: args withContext: ctx	args size = 1		ifFalse: [ MalWrongArity				signal: ('quote requires 1 argument (got {1})' format: {args size}) ].	^ args first! !CommandLineHandler subclass: #MalStep	instanceVariableNames: 'ctx'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep commentStamp: 'WilfredHughes 4/29/2019 10:05' prior: 0!I am the base class for all Mal command line handlers. I write a prompt, read input from the user, then dispatch.!!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 5/25/2019 12:15'!rep: aString	^ [ Mal rep: aString in: ctx ]		on: MalError		do: [ :ex | ex messageText ]! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:08'!readInputLine	self stdout << 'user> '.	^ (Stdio stdin upTo: Character lf asInteger) asString! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 6/21/2019 10:12'!activate	[ self activateUnchecked ]		on: Error		do: [ self stdout				<< thisContext longStack;				lf.			self exitFailure ]! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 6/15/2019 21:45'!activateUnchecked	| input |	input := self readInputLine.	[ input isEmptyOrNil ]		whileFalse: [ self stdout				<< (self rep: input) asString;				lf.			input := self readInputLine ].	self stdout lf.	self exitSuccess! !!MalStep methodsFor: 'initialization' stamp: 'WilfredHughes 6/2/2019 20:44'!initialize	super initialize.	ctx := MalContext default		stdout: self stdout;		yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep class	instanceVariableNames: ''!!MalStep class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:17'!commandName	^ ''! !MalStep subclass: #MalStep0	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep0 commentStamp: 'WilfredHughes 4/29/2019 10:03' prior: 0!I am the simplest Mal REPL, simply echoing my input to the user.!!MalStep0 methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:16'!rep: aString	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep0 class	instanceVariableNames: ''!!MalStep0 class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:15'!commandName	^ 'step0_mal'! !MalStep subclass: #MalStep1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep1 commentStamp: 'WilfredHughes 5/7/2019 23:46' prior: 0!I am a simple Mal REPL, parsing then printing my input.!!MalStep1 methodsFor: 'activation' stamp: 'WilfredHughes 5/14/2019 10:00'!rep: aString	^ [Mal print: (Mal read: aString)] on: MalError do: [ :ex | ex messageText  ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep1 class	instanceVariableNames: ''!!MalStep1 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 01:19'!commandName	^ 'step1_mal'! !MalStep subclass: #MalStep2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep2 commentStamp: 'WilfredHughes 5/7/2019 23:45' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image wmal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep2 class	instanceVariableNames: 'env'!!MalStep2 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/7/2019 23:47'!commandName	^ 'step2_mal'! !MalStep subclass: #MalStep3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep3 commentStamp: 'WilfredHughes 5/14/2019 09:55' prior: 0!I am a CLI interface for executing Mal expressions, supporting binding of variables.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step3_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep3 class	instanceVariableNames: 'env'!!MalStep3 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/14/2019 09:56'!commandName	^ 'step3_mal'! !MalStep subclass: #MalStep4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep4 commentStamp: 'WilfredHughes 5/22/2019 10:21' prior: 0!I am a CLI interface for executing Mal expressions, supporting binding of variables.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step4_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep4 class	instanceVariableNames: 'env'!!MalStep4 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/22/2019 10:21'!commandName	^ 'step4_mal'! !MalStep subclass: #MalStep5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep5 commentStamp: 'WilfredHughes 6/2/2019 20:56' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step5_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep5 class	instanceVariableNames: 'env'!!MalStep5 class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 20:57'!commandName	^ 'step5_mal'! !MalStep subclass: #MalStep6	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep6 commentStamp: 'WilfredHughes 6/5/2019 00:47' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step6_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep6 class	instanceVariableNames: 'env'!!MalStep6 class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 23:57'!commandName	^ 'step6_mal'! !MalStep subclass: #MalStep7	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep7 commentStamp: 'WilfredHughes 6/15/2019 20:55' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:Interactively:    $ ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step7_mal 2>/dev/nullOne-off execution:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step7_mal 2>/dev/nullIf you encounter a bug and want to use Pharo's debugger:    $ echo '(+ 1 2)' |~/Pharo/vms/70-x64/pharo ~/Pharo/images/WMal/WMal.image step7_mal!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep7 class	instanceVariableNames: 'env'!!MalStep7 class methodsFor: 'accessing' stamp: 'WilfredHughes 6/6/2019 10:02'!commandName	^ 'step7_mal'! !MalLiteral subclass: #MalStringLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStringLiteral commentStamp: 'WilfredHughes 5/29/2019 22:53' prior: 0!I convert strings '"foo"' into MAL strings.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStringLiteral class	instanceVariableNames: ''!!MalStringLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 22:57'!fromToken: token"TODO: Check for a closing double-quote on string literals."	^ MalString withValue: (self stringContents: token)! !!MalStringLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 22:54'!matches: aString	^ aString first = $"! !!MalStringLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 22:55'!stringContents: token	| chars isEscape |	"Remove the double quotes and unescape a string literal."	isEscape := false.	chars := OrderedCollection new.	token allButFirst allButLast		do: [ :char | 			isEscape				ifTrue: [ char = $n						ifTrue: [ chars add: Character cr ]						ifFalse: [ chars add: char ].					isEscape := false ]				ifFalse: [ char = $\						ifTrue: [ isEscape := true ]						ifFalse: [ chars add: char ] ] ].	^ '' join: chars! !MalError subclass: #MalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #MalTokenizer	instanceVariableNames: ''	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'MakeALisp'!!MalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalTokenizer class	instanceVariableNames: ''!!MalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 6/5/2019 23:58'!fromString: aString	"Return a collection of all the tokens in our string."	| pattern matcher result |	"This isn't exactly the same as the MAL docs.   We are forced to treat [ and ] separately due to syntax limitations   in the regex engine (a range cannot contain [, see 	https://stackoverflow.com/questions/45824000/) and 	we ban carriage return/line feeds in comments."	pattern := '[\s,]*(~@|\[|\]|[{}()''`~^@]|"(\\.|[^\\"])*"|;[^', Character cr asString , Character lf asString , ']*|([^]\s{}(''"`,;)])*)'.	matcher := RxMatcher forString: pattern.	result := matcher		matchesOnStream: aString readStream		collect: [ :s | matcher subexpression: 2 ].	^ result reject: [ :str | str isEmpty or: [ str first = $; ] ]! !MalSpecialForm subclass: #MalTry	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalTry commentStamp: 'WilfredHughes 6/20/2019 09:47' prior: 0!I represent the try* special form.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalTry class	instanceVariableNames: ''!!MalTry class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/21/2019 09:46'!call: args withContext: ctx	| catchExpr |	args isEmpty		ifTrue: [ MalError signal: 'try* requires at least one argument' ].	catchExpr := nil.	args size = 2		ifTrue: [ catchExpr := args second ].	catchExpr ifNil: [ ^ args first evalIn: ctx ].	^ [ args first evalIn: ctx ]		on: MalError		do: [ :ex | self evalCatch: catchExpr withException: ex andContext: ctx ]! !!MalTry class methodsFor: 'accessing' stamp: 'WilfredHughes 6/20/2019 09:47'!malName	^ 'try*'! !!MalTry class methodsFor: 'accessing' stamp: 'WilfredHughes 6/21/2019 10:11'!evalCatch: expr withException: ex andContext: ctx	"Evaluate a (catch* exc ...) expression."	| excValue newEnv newCtx excSym |	expr isPair		ifFalse: [ MalError signal: 'catch* expression must be a non-empty list' ].	expr value first = (MalSymbol withValue: 'catch*')		ifFalse: [ MalError signal: 'catch* expression must start with catch*' ].	expr size = 3		ifFalse: [ MalError				signal: 'catch* expression is wrong size: should be catch*, sym, expr' ].	excSym := expr value second.	excSym class = MalSymbol		ifFalse: [ MalError signal: 'catch* requires a symbol to bind the exception' ].	"Use the value passed to throw, or the error text for built-in errors."	excValue := (ex tag isKindOf: MalType)		ifTrue: [ ex tag ]		ifFalse: [ MalString withValue: ex messageText ].	newEnv := MalEnv withOuter: ctx env.	newEnv at: excSym put: excValue.	newCtx := ctx withEnv: newEnv.	^ expr value third evalIn: newCtx! !Object subclass: #MalType	instanceVariableNames: 'value meta'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalType commentStamp: 'WilfredHughes 5/30/2019 09:59' prior: 0!I am the base class for all MAL types. Every type wraps an instance variable 'value', and knows how to print and evaluate.!!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/13/2019 20:01'!macroexpandIn: ctx	^ self! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 15:43'!meta: anObject	meta := anObject! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:00'!isIterable	^ false! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/7/2019 21:06'!isPair	^ false! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 15:44'!value: aSmalltalkValue	value := aSmalltalkValue.! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	self subclassResponsibility ! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 15:43'!meta	^ meta! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/13/2019 10:08'!evalIn: ctx	"Default behaviour is that types evaluate to themselves."	^ self! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:16'!isTruthy^ true! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/13/2019 19:55'!isMacro	^ false! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 19:35'!isCallable	^ false! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/14/2019 00:49'!macroexpandAllIn: ctx	| val previousVal |	val := self.	previousVal := nil.	[ val ~~ previousVal ] whileTrue: [ previousVal := val. val := val macroexpandIn: ctx ].	^ val! !!MalType methodsFor: 'comparing' stamp: 'WilfredHughes 5/30/2019 23:20'!hash ^ self value hash! !!MalType methodsFor: 'comparing' stamp: 'WilfredHughes 6/3/2019 22:05'!= anObject   (self isIterable & anObject isIterable) ifTrue: [^ value = anObject value].   self class = anObject class ifFalse: [ ^ false ].   ^ value = anObject value! !!MalType methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 00:36'!call: args withContext: ctx	"Try to call this value as a function."	MalNotCallable signal: 'Not a function: ' , self asReadableString! !!MalType methodsFor: 'converting' stamp: 'WilfredHughes 6/4/2019 00:36'!asString ^ self asReadableString! !!MalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalType class	instanceVariableNames: ''!!MalType class methodsFor: 'initialization' stamp: 'WilfredHughes 5/30/2019 10:00'!withValue: aDictionary	| instance |	instance := self new.	instance value: aDictionary.	^ instance! !MalType subclass: #MalAtom	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAtom commentStamp: 'WilfredHughes 6/3/2019 22:14' prior: 0!I represent atom values in MAL.!!MalAtom methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ '(atom ', self value asReadableString , ')'! !MalType subclass: #MalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!MalBool methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ self value asString! !!MalBool methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:17'!isTruthy^ self value! !MalType subclass: #MalCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalCallable commentStamp: 'WilfredHughes 6/23/2019 14:22' prior: 0!I'm the base class for all callable values in MAL.This covers both built-in functions and user-defined functions. Notethat macros are special cases of functions.!!MalCallable methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 14:23'!isCallable ^ true! !MalCallable subclass: #MalClosure	instanceVariableNames: 'env bindings variadicSym body isMacro'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalClosure commentStamp: 'WilfredHughes 5/19/2019 10:03' prior: 0!I represent (fn* ...) expressions in MAL.!!MalClosure methodsFor: 'printing' stamp: 'WilfredHughes 6/22/2019 15:32'!printOn: aStream	| inner |	inner := ' ' join: (body collect: #printString).	aStream		nextPutAll: 'a MalClosure(';		nextPutAll: inner;		nextPutAll: ')'! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 10:00'!body: anObject	body := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 6/13/2019 19:48'!isMacroCall	^ isMacro! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 10:00'!bindings: anObject	bindings := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 6/13/2019 19:49'!isMacro	^ isMacro! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 6/11/2019 10:03'!isMacro: anObject	^ isMacro := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:27'!bindings	^ bindings! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:17'!env: anEnv	env := anEnv! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 20:45'!asReadableString   isMacro ifTrue: [ ^'#<macro>' ] ifFalse: [  	^ '#<function>']! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:25'!variadicSym: anObject	variadicSym := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:25'!variadicSym	^ variadicSym! !!MalClosure methodsFor: 'evaluating' stamp: 'WilfredHughes 6/22/2019 15:35'!call: args withContext: callingCtx	| bodyEnv result bodyCtx |	args size < bindings size		ifTrue: [ MalWrongArity signal: 'not enough arguments to closure' ].	args size > bindings size & variadicSym isNil		ifTrue: [ MalWrongArity signal: 'too many arguments to closure' ].	"Create an environment combining the closure env and the bound symbols."	bodyEnv := MalEnv withOuter: env.	bindings withIndexDo: [ :sym :i | bodyEnv at: sym put: (args at: i) ].	variadicSym isNotNil		ifTrue: [ bodyEnv				at: variadicSym				put: (MalList withValue: (args allButFirst: bindings size)) ].	bodyCtx := callingCtx withEnv: bodyEnv.	"Evaluate the body and return the value of the last item."	result := nil.	body do: [ :e | result := e evalIn: bodyCtx ].	^ result! !MalCallable subclass: #MalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFunction commentStamp: 'WilfredHughes 5/25/2019 13:37' prior: 0!I represent built-in functions in MAL.If a child implements the malName method, it will be included in the default environment.!!MalFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/6/2019 10:21'!ensure: args haveArity: arity	| msg |	msg := 'The function {1} takes {2} argument{3} (got {4})'		format:			{self class malName.			arity.			(arity = 1				ifTrue: [ '' ]				ifFalse: [ 's' ]). args size}.	args size = arity		ifFalse: [ MalWrongArity signal: msg ]! !!MalFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:32'!call: args withContext: ctx	self subclassResponsibility! !!MalFunction methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/23/2019 15:34'!ensure: arg hasType: aClass	arg class = aClass		ifFalse: [ MalError				signal:					('{1} requires an argument of type {2}'						format:							{self class malName.							aClass name asString}) ]! !!MalFunction methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/23/2019 15:34'!ensure: args haveType: aClass	args		do: [ :arg | 			self ensure: arg hasType: aClass ]! !!MalFunction methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/24/2019 09:54'!ensure: args haveMinArity: arity	| msg |	msg := 'The function {1} requires at least {2} argument{3} (got {4})'		format:			{self class malName.			arity.			(arity = 1				ifTrue: [ '' ]				ifFalse: [ 's' ]).			args size}.	args size < arity		ifTrue: [ MalWrongArity signal: msg ]! !!MalFunction methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ '#<built-in function>'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFunction class	instanceVariableNames: ''!!MalFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:37'!malName^ nil! !MalFunction subclass: #MalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAdd commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function + in MAL.!!MalAdd methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 00:37'!call: args withContext: ctx	"Add args together. TODO: type errors."	| total |	self ensure: args haveType: MalInteger.	total := (args collect: #value) sum.	^ MalInteger withValue: total! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAdd class	instanceVariableNames: ''!!MalAdd class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:37'!malName ^ '+'! !MalFunction subclass: #MalApplyFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalApplyFunction commentStamp: 'WilfredHughes 6/18/2019 22:37' prior: 0!I represent the apply function.!!MalApplyFunction methodsFor: 'accessing' stamp: 'WilfredHughes 6/18/2019 22:49'!call: args withContext: ctx	| func funcArgs |	args size < 2		ifTrue: [ MalError signal: 'apply requires at least two arguments' ].	func := args first.	func isCallable		ifFalse: [ MalError signal: 'first argument to apply must be a callable' ].	funcArgs := OrderedCollection new.	funcArgs addAll: args allButFirst allButLast.	args last isIterable ifFalse: [ MalError signal: 'the last argument to apply must be iterable' ].	funcArgs addAll: args last value.	^ func call: funcArgs withContext: ctx! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalApplyFunction class	instanceVariableNames: ''!!MalApplyFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/18/2019 22:37'!malName	^ 'apply'! !MalFunction subclass: #MalAssoc	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAssoc commentStamp: 'WilfredHughes 6/17/2019 09:54' prior: 0!I represent the assoc function.!!MalAssoc methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:14'!call: args withContext: ctx	| items extraItems |	args isEmpty		ifTrue: [ MalError signal: 'assoc requires an argument' ].	args first class = MalHashMap		ifFalse: [ MalError signal: 'first argument to assoc must be a hash map' ].	items := args first value copy.	extraItems := args allButFirst.	extraItems size even		ifFalse: [ MalError signal: 'assoc requires an even number of key-values' ].	extraItems pairsDo: [ :k :v | items at: k put: v ].	^ MalHashMap withValue: items! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAssoc class	instanceVariableNames: ''!!MalAssoc class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 22:37'!malName	^ 'assoc'! !MalFunction subclass: #MalConcat	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalConcat commentStamp: 'WilfredHughes 6/6/2019 10:06' prior: 0!I represent the concat function in MAL.!!MalConcat methodsFor: 'evaluating' stamp: 'WilfredHughes 6/6/2019 10:08'!call: args withContext: ctx	| result |	args do: [ :arg | arg isIterable ifFalse: [ MalError signal: 'concat requires iterable arguments' ] ].	result := OrderedCollection new.	args do: [ :arg | result addAll: arg value ].	^ MalList withValue: result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalConcat class	instanceVariableNames: ''!!MalConcat class methodsFor: 'accessing' stamp: 'WilfredHughes 6/6/2019 10:07'!malName	^ 'concat'! !MalFunction subclass: #MalConj	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalConj commentStamp: 'WilfredHughes 6/23/2019 18:39' prior: 0!I represent the conj function.!!MalConj methodsFor: 'evaluating' stamp: 'WilfredHughes 6/24/2019 10:12'!call: args withContext: ctx	| items extraItems |	self ensure: args haveMinArity: 1.	args first isIterable		ifFalse: [ MalError signal: 'conj requires an iterable as its first argument' ].	items := args first value copy.	extraItems := args allButFirst.	args first class = MalList		ifTrue: [ extraItems do: [ :item | items addFirst: item ].			^MalList withValue: items ]		ifFalse: [ extraItems do: [ :item | items addLast: item ].			^MalVector withValue: items ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalConj class	instanceVariableNames: ''!!MalConj class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 18:39'!malName	^ 'conj'! !MalFunction subclass: #MalCons	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalCons commentStamp: 'WilfredHughes 6/6/2019 10:05' prior: 0!I represent the cons function in MAL.!!MalCons methodsFor: 'evaluating' stamp: 'WilfredHughes 6/6/2019 10:16'!call: args withContext: ctx	| result |	self ensure: args haveArity: 2.	result := OrderedCollection with: args first.	args second isIterable		ifFalse: [ MalError signal: 'second argument to cons should be iterable' ].	result addAll: args second value.	^ MalList withValue: result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalCons class	instanceVariableNames: ''!!MalCons class methodsFor: 'accessing' stamp: 'WilfredHughes 6/6/2019 10:05'!malName	^ 'cons'! !MalFunction subclass: #MalContainsPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalContainsPredicate commentStamp: 'WilfredHughes 6/17/2019 22:50' prior: 0!I represent the contains? function.!!MalContainsPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 22:52'!call: args withContext: ctx	| hashmap |	self ensure: args haveArity: 2.	hashmap := args first.	hashmap class = MalHashMap		ifFalse: [ MalError signal: 'first argument to contains must be a hash map' ].	^ hashmap value at: args second ifPresent: [ MalBool withValue: true ] ifAbsent: [ MalBool withValue: false ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalContainsPredicate class	instanceVariableNames: ''!!MalContainsPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 22:52'!malName	^ 'contains?'! !MalFunction subclass: #MalDissoc	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDissoc commentStamp: 'WilfredHughes 6/17/2019 22:38' prior: 0!I represent the dissoc function.!!MalDissoc methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 22:46'!call: args withContext: ctx	| items keysToRemove |	args isEmpty		ifTrue: [ MalError signal: 'dissoc requires an argument' ].	args first class = MalHashMap		ifFalse: [ MalError signal: 'first argument to dissoc must be a hash map' ].	items := args first value copy.	keysToRemove := args allButFirst.	keysToRemove do: [ :k | items removeKey: k ifAbsent: [  ] ].	^ MalHashMap withValue: items! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDissoc class	instanceVariableNames: ''!!MalDissoc class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 22:39'!malName	^ 'dissoc'! !MalFunction subclass: #MalDivide	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDivide commentStamp: 'WilfredHughes 11/6/2017 19:01' prior: 0!The built-in function / in MAL.!!MalDivide methodsFor: 'accessing' stamp: 'WilfredHughes 6/24/2019 09:58'!call: args withContext: ctx	"Divide args together. TODO: arity error"	| result |	self ensure: args haveMinArity: 1.	self ensure: args haveType: MalInteger.	result := args first value.	args allButFirstDo: [ :arg | result := result // arg value ].	^ MalInteger withValue: result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDivide class	instanceVariableNames: ''!!MalDivide class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ '/'! !MalFunction subclass: #MalEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEqual commentStamp: 'WilfredHughes 5/25/2019 12:31' prior: 0!I represent the = function in MAL.!!MalEqual methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 01:03'!call: args withContext: ctx	self ensure: args haveArity: 2.	^ MalBool withValue: args first = args second! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEqual class	instanceVariableNames: ''!!MalEqual class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ '='! !MalFunction subclass: #MalFunctionOneArg	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFunctionOneArg commentStamp: 'WilfredHughes 5/19/2019 09:53' prior: 0!I'm a base class for built-in function that take exactly one argument.!!MalFunctionOneArg methodsFor: 'evaluating' stamp: 'WilfredHughes 6/13/2019 10:18'!callArg: arg withContext: ctx	self subclassResponsibility! !!MalFunctionOneArg methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 19:31'!call: args withContext: env	self ensure: args haveArity: 1.	^ self callArg: args first withContext: env! !MalFunctionOneArg subclass: #MalAtomFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAtomFunction commentStamp: 'WilfredHughes 6/3/2019 22:16' prior: 0!I represent the function that creates atom values in MAL.!!MalAtomFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:17'!callArg: arg withContext: ctx	^ MalAtom withValue: arg! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAtomFunction class	instanceVariableNames: ''!!MalAtomFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:17'!malName	^ 'atom'! !MalFunctionOneArg subclass: #MalAtomPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAtomPredicate commentStamp: 'WilfredHughes 6/3/2019 22:17' prior: 0!I represent the atom? function in MAL.!!MalAtomPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:18'!callArg: arg withContext: ctx	^ MalBool withValue: (arg class = MalAtom)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAtomPredicate class	instanceVariableNames: ''!!MalAtomPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:17'!malName	^ 'atom?'! !MalFunctionOneArg subclass: #MalCount	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalCount commentStamp: 'WilfredHughes 5/18/2019 15:47' prior: 0!I represent the count function in MAL.!!MalCount methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:03'!callArg: arg withContext: ctx	"MAL requires nil to return 0, so return 0 for any non-list."	arg isIterable		ifFalse: [ ^ MalInteger withValue: 0 ].	^ MalInteger withValue: arg size! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalCount class	instanceVariableNames: ''!!MalCount class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'count'! !MalFunctionOneArg subclass: #MalDeref	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDeref commentStamp: 'WilfredHughes 6/3/2019 22:19' prior: 0!I represent the deref function in MAL.!!MalDeref methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:20'!callArg: arg withContext: env	arg class = MalAtom ifFalse: [ MalError signal: 'deref requires an atom' ].	^ arg value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDeref class	instanceVariableNames: ''!!MalDeref class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:20'!malName	^ 'deref'! !MalFunctionOneArg subclass: #MalEmptyPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEmptyPredicate commentStamp: 'WilfredHughes 5/18/2019 15:37' prior: 0!I represent the empty? function in MAL.!!MalEmptyPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:03'!callArg: arg withContext: ctx	arg isIterable		ifFalse: [ ^ MalBool withValue: false ].	^ MalBool withValue: arg value isEmpty! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEmptyPredicate class	instanceVariableNames: ''!!MalEmptyPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'empty?'! !MalFunctionOneArg subclass: #MalEval	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEval commentStamp: 'WilfredHughes 6/2/2019 23:53' prior: 0!I represent the eval built-in function in MAL.I do not handle evaluation (see the evalIn: message), but I expose evaluation to the user.!!MalEval methodsFor: 'evaluating' stamp: 'WilfredHughes 6/6/2019 10:00'!callArg: arg withContext: ctx	| evalCtx |	"Eval may not access local variables, according to the MAL test suite."	evalCtx := ctx withEnv: ctx globalEnv.	^ arg evalIn: evalCtx! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEval class	instanceVariableNames: ''!!MalEval class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 00:00'!malName	^ 'eval'! !MalFunctionOneArg subclass: #MalFalsePredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFalsePredicate commentStamp: 'WilfredHughes 6/17/2019 23:08' prior: 0!I represent the false? function.!!MalFalsePredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:10'!callArg: arg withContext: ctx	^ MalBool withValue: (arg = (MalBool withValue: false))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFalsePredicate class	instanceVariableNames: ''!!MalFalsePredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 23:09'!malName	^ 'false?'! !MalFunctionOneArg subclass: #MalFirst	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFirst commentStamp: 'WilfredHughes 6/14/2019 10:19' prior: 0!I represent the first function.!!MalFirst methodsFor: 'evaluating' stamp: 'WilfredHughes 6/14/2019 10:28'!callArg: arg withContext: ctx	arg isPair	   ifTrue: [ ^ arg value first ]		ifFalse: [ ^ MalNil new ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFirst class	instanceVariableNames: ''!!MalFirst class methodsFor: 'accessing' stamp: 'WilfredHughes 6/14/2019 10:19'!malName	^ 'first'! !MalFunctionOneArg subclass: #MalFnPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFnPredicate commentStamp: 'WilfredHughes 6/23/2019 16:34' prior: 0!I represent the fn? function.!!MalFnPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/25/2019 09:46'!callArg: arg withContext: ctx	^ MalBool withValue: (arg isCallable and: [arg isMacro not])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFnPredicate class	instanceVariableNames: ''!!MalFnPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 16:36'!malName	^ 'fn?'! !MalFunction subclass: #MalGet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGet commentStamp: 'WilfredHughes 6/17/2019 22:47' prior: 0!I represent the get function.!!MalGet methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:15'!call: args withContext: ctx	| hashmap |	self ensure: args haveArity: 2.	hashmap := args first.	hashmap class = MalHashMap		ifFalse: [ ^ MalNil new ].	^ hashmap value at: args second ifAbsent: [ MalNil new ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalGet class	instanceVariableNames: ''!!MalGet class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 22:49'!malName	^ 'get'! !MalFunction subclass: #MalGreaterThan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGreaterThan commentStamp: 'WilfredHughes 5/18/2019 15:52' prior: 0!I represent the > function in MAL.!!MalGreaterThan methodsFor: 'accessing' stamp: 'WilfredHughes 6/24/2019 10:00'!call: args withContext: ctx	| x y |	self ensure: args haveArity: 2.	self ensure: args haveType: MalInteger .	x := args first.	y := args second.	^ MalBool withValue: x value > y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalGreaterThan class	instanceVariableNames: ''!!MalGreaterThan class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '>'! !MalFunction subclass: #MalGreaterThanOrEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGreaterThanOrEqual commentStamp: 'WilfredHughes 5/18/2019 16:01' prior: 0!I represent the >= function in MAL.!!MalGreaterThanOrEqual methodsFor: 'accessing' stamp: 'WilfredHughes 6/24/2019 10:00'!call: args withContext: ctx	| x y |	self ensure: args haveArity: 2.	self ensure: args haveType: MalInteger.	x := args first.	y := args second.	^ MalBool withValue: x value >= y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalGreaterThanOrEqual class	instanceVariableNames: ''!!MalGreaterThanOrEqual class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '>='! !MalType subclass: #MalHashMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalHashMap commentStamp: 'WilfredHughes 5/30/2019 09:54' prior: 0!I represent hash maps {:foo "bar"} in MAL.!!MalHashMap methodsFor: 'accessing' stamp: 'WilfredHughes 6/22/2019 16:00'!asString	| printedItems |	printedItems := OrderedCollection new.	value		associationsDo: [ :assoc | 			printedItems add: assoc key asString.			printedItems add: assoc value asString ].	^ '{' , (' ' join: printedItems) , '}'! !!MalHashMap methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	| printedItems |	printedItems := OrderedCollection new.	value		associationsDo: [ :assoc | 			printedItems add: assoc key asReadableString.			printedItems add: assoc value asReadableString ].	^ '{' , (' ' join: printedItems) , '}'! !!MalHashMap methodsFor: 'accessing' stamp: 'WilfredHughes 5/31/2019 10:27'!evalIn: ctx	| evalledItems |	evalledItems := self value		associations collect: [ :assoc | ((assoc key) evalIn: ctx) -> ((assoc value) evalIn: ctx) ].	^ MalHashMap withValue: (Dictionary newFrom: evalledItems)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalHashMap class	instanceVariableNames: ''!!MalHashMap class methodsFor: 'initialization' stamp: 'WilfredHughes 5/31/2019 00:13'!withItems: items	| value |	value := Dictionary new.	items pairsDo: [ :k :v | value at: k put: v ].	^ self withValue: value! !MalFunction subclass: #MalHashMapFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalHashMapFunction commentStamp: 'WilfredHughes 6/15/2019 22:08' prior: 0!I represent the hash-map function.!!MalHashMapFunction methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 09:41'!call: args withContext: ctx	args size even		ifFalse: [ MalError signal: 'hash-map takes an even number of arguments' ].	^ MalHashMap withItems: args! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalHashMapFunction class	instanceVariableNames: ''!!MalHashMapFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 22:08'!malName	^ 'hash-map'! !MalType subclass: #MalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!MalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ self value asString! !MalFunctionOneArg subclass: #MalKeys	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeys commentStamp: 'WilfredHughes 6/17/2019 22:55' prior: 0!I represent the keys function.!!MalKeys methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 22:59'!callArg: arg withContext: ctx	arg class = MalHashMap		ifFalse: [ MalError signal: 'keys requires a hash map argument' ].	^ MalList withValue: (OrderedCollection newFrom: arg value keys)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalKeys class	instanceVariableNames: ''!!MalKeys class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 22:58'!malName	^ 'keys'! !MalType subclass: #MalKeyword	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeyword commentStamp: 'WilfredHughes 3/13/2018 08:30' prior: 0!I represent keywords  in MAL.Keywords are symbols that start with :, e.g. :foo.Keywords evaluate to themselves.!!MalKeyword methodsFor: 'accessing' stamp: 'WilfredHughes 6/22/2019 15:50'!asReadableString	^ value! !MalFunctionOneArg subclass: #MalKeywordFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeywordFunction commentStamp: 'WilfredHughes 6/15/2019 22:02' prior: 0!I represent the keyword function.!!MalKeywordFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/18/2019 23:15'!callArg: arg withContext: ctx	arg class = MalString		ifFalse: [ MalError signal: 'keyword requires a string argument' ].	^ MalKeyword withValue: ':' ,arg value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalKeywordFunction class	instanceVariableNames: ''!!MalKeywordFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 22:04'!malName	^ 'keyword'! !MalFunctionOneArg subclass: #MalKeywordPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeywordPredicate commentStamp: 'WilfredHughes 6/15/2019 22:00' prior: 0!I represent the keyword? function.!!MalKeywordPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 22:04'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalKeyword! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalKeywordPredicate class	instanceVariableNames: ''!!MalKeywordPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 22:02'!malName	^ 'keyword?'! !MalFunction subclass: #MalLessThan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLessThan commentStamp: 'WilfredHughes 5/18/2019 16:00' prior: 0!I represent the < function in MAL.!!MalLessThan methodsFor: 'accessing' stamp: 'WilfredHughes 6/24/2019 10:00'!call: args withContext: ctx	| x y |	self ensure: args haveArity: 2.	self ensure: args haveType: MalInteger.	x := args first.	y := args second.	^ MalBool withValue: x value < y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLessThan class	instanceVariableNames: ''!!MalLessThan class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '<'! !MalFunction subclass: #MalLessThanOrEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLessThanOrEqual commentStamp: 'WilfredHughes 5/18/2019 16:02' prior: 0!I represent the <= function in MAL.!!MalLessThanOrEqual methodsFor: 'accessing' stamp: 'WilfredHughes 6/24/2019 10:01'!call: args withContext: ctx	| x y |	self ensure: args haveArity: 2.	self ensure: args haveType: MalInteger.	x := args first.	y := args second.	^ MalBool withValue: x value <= y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLessThanOrEqual class	instanceVariableNames: ''!!MalLessThanOrEqual class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '<='! !MalType subclass: #MalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalList commentStamp: 'WilfredHughes 6/15/2019 10:24' prior: 0!I represent a list value in MAL.My API is similar to OrderedCollection for convenience.!!MalList methodsFor: 'converting' stamp: 'WilfredHughes 6/3/2019 22:10'!asString	| inner |	inner := ' ' join: (value collect: #asString).	^ '(' , inner , ')'! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/7/2019 21:06'!isPair	^ self value isNotEmpty! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:00'!isIterable ^ true! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/7/2019 21:29'!allButFirst: n	^ self class withValue: (value allButFirst: n)! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 10:20'!initialize super initialize .value := OrderedCollection new.! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/14/2019 00:59'!macroexpandIn: ctx	| head headVal |	self value ifEmpty: [ ^ self ].	head := self value first.	"If the first item evaluates to a macro."	head class = MalSymbol		ifFalse: [ ^ self ].	headVal := [ head evalIn: ctx ]		on: MalUnboundSymbol		do: [ ^ self ].	headVal isMacro		ifTrue: [ ^ headVal call: (self value allButFirst) withContext: ctx ]		ifFalse: [ ^ self ].! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString   | inner |inner := ' ' join: (value collect: #asReadableString).^ '(', inner, ')'! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/7/2019 21:56'!allButFirst	^ self allButFirst: 1! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/14/2019 01:01'!evalIn: ctx	| items evalledItems func expanded |	expanded := self macroexpandAllIn: ctx.	items := expanded value.	"A call is a non-empty list after macro expansion."	expanded isPair ifFalse: [ ^ expanded ].	"Special forms."	(MalSpecialForm matchesSymbol: items first)		ifNotNil: [ :f | ^ f call: items allButFirst withContext: ctx ].	"Evaluate all the items in the list, then call the first arg with the rest."	evalledItems := items collect: [ :item | item evalIn: ctx ].	func := evalledItems first.	^ func call: evalledItems allButFirst withContext: ctx! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalList class	instanceVariableNames: ''!!MalList class methodsFor: 'instance creation' stamp: 'WilfredHughes 6/15/2019 10:25'!with: value^ self withValue: (OrderedCollection with: value)! !!MalList class methodsFor: 'instance creation' stamp: 'WilfredHughes 6/15/2019 10:29'!with: value1 with: value2 with: value3	^ self withValue: (OrderedCollection with: value1 with: value2 with: value3)! !!MalList class methodsFor: 'instance creation' stamp: 'WilfredHughes 6/15/2019 10:25'!with: value1 with: value2	^ self withValue: (OrderedCollection with: value1 with: value2)! !MalFunction subclass: #MalListFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalListFunction commentStamp: 'WilfredHughes 5/18/2019 15:26' prior: 0!I represent the list function in MAL.!!MalListFunction methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	^ MalList withValue: args! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalListFunction class	instanceVariableNames: ''!!MalListFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ 'list'! !MalFunctionOneArg subclass: #MalListPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalListPredicate commentStamp: 'WilfredHughes 5/18/2019 15:28' prior: 0!I represent the list? function in MAL.!!MalListPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalListPredicate class	instanceVariableNames: ''!!MalListPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'list?'! !MalFunctionOneArg subclass: #MalMacroPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMacroPredicate commentStamp: 'WilfredHughes 6/23/2019 16:39' prior: 0!I represent the macro? function.!!MalMacroPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 16:39'!callArg: arg withContext: ctx	^ MalBool withValue: arg isMacro! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMacroPredicate class	instanceVariableNames: ''!!MalMacroPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 16:39'!malName	^ 'macro?'! !MalFunction subclass: #MalMapFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMapFunction commentStamp: 'WilfredHughes 6/18/2019 22:50' prior: 0!I represent the map function.!!MalMapFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/18/2019 23:13'!call: args withContext: ctx	| func result |	self ensure: args haveArity: 2.	func := args first.	func isCallable		ifFalse: [ MalError signal: 'first argument to map must be a callable' ].	result := OrderedCollection new.	args second isIterable		ifFalse: [ MalError signal: 'the second argument to map must be iterable' ].	result := args second value collect: [ :arg | func call: (OrderedCollection with: arg) withContext: ctx ].	^ MalList withValue: result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMapFunction class	instanceVariableNames: ''!!MalMapFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/18/2019 22:50'!malName	^ 'map'! !MalFunctionOneArg subclass: #MalMapPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMapPredicate commentStamp: 'WilfredHughes 6/17/2019 09:52' prior: 0!I represent the map? function.!!MalMapPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 09:53'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalHashMap ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMapPredicate class	instanceVariableNames: ''!!MalMapPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 09:53'!malName	^ 'map?'! !MalFunctionOneArg subclass: #MalMetaFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMetaFunction commentStamp: 'WilfredHughes 6/23/2019 14:24' prior: 0!I represent the meta function that extracts metadata from callables.!!MalMetaFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 16:00'!callArg: arg withContext: ctx   ^arg meta ifNil: [ MalNil new ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMetaFunction class	instanceVariableNames: ''!!MalMetaFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 14:25'!malName	^ 'meta'! !MalFunction subclass: #MalMultiply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMultiply commentStamp: 'WilfredHughes 11/6/2017 18:57' prior: 0!The built-in function * in MAL.!!MalMultiply methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 00:47'!call: args withContext: ctx	"Multiply args together."	| total |		self ensure: args haveType: MalInteger.	total := 1.	args do: [ :arg | total := total * arg value ].	^ MalInteger withValue: total! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMultiply class	instanceVariableNames: ''!!MalMultiply class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '*'! !MalType subclass: #MalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ 'nil'! !!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 14:44'!printOn: aStream	aStream		nextPutAll: 'a WMalNil'! !!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:16'!isTruthy^ false! !MalFunctionOneArg subclass: #MalNilPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNilPredicate commentStamp: 'WilfredHughes 6/17/2019 23:05' prior: 0!I represent the nil? function.!!MalNilPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:10'!callArg: arg withContext: ctx	^ MalBool withValue: (arg = (MalNil new))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNilPredicate class	instanceVariableNames: ''!!MalNilPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 23:07'!malName	^ 'nil?'! !MalFunction subclass: #MalNth	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNth commentStamp: 'WilfredHughes 6/14/2019 10:34' prior: 0!I represent the nth function.!!MalNth methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 10:07'!call: args withContext: ctx	self ensure: args haveArity: 2.	args first isIterable		ifFalse: [ MalError signal: 'first argument to nth should be iterable' ].	args second class = MalInteger		ifFalse: [ MalError signal: 'second argument to nth should be an integer' ].	[ ^ args first value at: args second value + 1 ]		on: SubscriptOutOfBounds		do: [ MalError				signal:					('Out of bounds: cannot access {1} in a {2} item iterable'						format:							{args second value.							args first size}) ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNth class	instanceVariableNames: ''!!MalNth class methodsFor: 'accessing' stamp: 'WilfredHughes 6/14/2019 10:34'!malName	^ 'nth'! !MalFunctionOneArg subclass: #MalNumberPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNumberPredicate commentStamp: 'WilfredHughes 6/23/2019 00:48' prior: 0!I represent the number? function.!!MalNumberPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 00:48'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNumberPredicate class	instanceVariableNames: ''!!MalNumberPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 00:49'!malName	^ 'number?'! !MalFunction subclass: #MalPrStr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrStr commentStamp: 'WilfredHughes 6/3/2019 09:25' prior: 0!I repressent the pr-str function in MAL.!!MalPrStr methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 00:36'!call: args withContext: ctx	| printedArgs |	printedArgs := args collect: [ :arg | arg asReadableString ].	^ MalString withValue: (' ' join: printedArgs)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalPrStr class	instanceVariableNames: ''!!MalPrStr class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 09:27'!malName	^ 'pr-str'! !MalFunction subclass: #MalPrintln	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrintln commentStamp: 'WilfredHughes 6/3/2019 21:50' prior: 0!I represent the println function in MAL.!!MalPrintln methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 21:57'!call: args withContext: ctx	ctx stdout		<< (' ' join: (args collect: #asString));		lf.	^ MalNil new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalPrintln class	instanceVariableNames: ''!!MalPrintln class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:12'!malName	^ 'println'! !MalFunction subclass: #MalPrn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrn commentStamp: 'WilfredHughes 5/22/2019 10:23' prior: 0!The built-in prn function in MAL.!!MalPrn methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 00:36'!call: args withContext: ctx  | printedArgs |printedArgs := args collect: [ :arg | arg asReadableString ].		ctx stdout		<< (' ' join: printedArgs);		lf.	^ MalNil new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalPrn class	instanceVariableNames: ''!!MalPrn class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'prn'! !MalFunctionOneArg subclass: #MalReadString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReadString commentStamp: 'WilfredHughes 6/2/2019 23:42' prior: 0!I represent the read-string built-in function in MAL.!!MalReadString methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 23:49'!callArg: arg withContext: ctx	arg class = MalString		ifFalse: [ ^ MalError signal: 'Expected a string' ].	^ Mal read: arg value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReadString class	instanceVariableNames: ''!!MalReadString class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 23:46'!malName	^ 'read-string'! !MalFunction subclass: #MalReset	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReset commentStamp: 'WilfredHughes 6/4/2019 00:39' prior: 0!I represent the reset!! function in MAL.!!MalReset methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 19:32'!call: args withContext: ctx	| atom |	self ensure: args haveArity: 2.	atom := args first.	atom class = MalAtom		ifFalse: [ MalError signal: 'first argument to reset!! must be an atom' ].	atom value: args second.	^ args second! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReset class	instanceVariableNames: ''!!MalReset class methodsFor: 'accessing' stamp: 'WilfredHughes 6/5/2019 00:44'!malName	^ 'reset!!'! !MalFunctionOneArg subclass: #MalRest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalRest commentStamp: 'WilfredHughes 6/14/2019 10:21' prior: 0!I represent the rest function.!!MalRest methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 10:23'!callArg: arg withContext: ctx	arg class = MalNil ifTrue: [ ^ MalList new ].	arg isIterable		ifFalse: [ ^ MalNil new ].	^ MalList withValue: arg value allButFirst! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalRest class	instanceVariableNames: ''!!MalRest class methodsFor: 'accessing' stamp: 'WilfredHughes 6/14/2019 10:21'!malName	^ 'rest'! !MalFunctionOneArg subclass: #MalSeq	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSeq commentStamp: 'WilfredHughes 6/23/2019 16:44' prior: 0!I represent the seq function.!!MalSeq methodsFor: 'evaluating' stamp: 'WilfredHughes 6/25/2019 09:52'!callArg: arg withContext: ctx	arg isPair		ifTrue: [ ^ MalList withValue: arg value ].	arg class = MalString & (arg value = '')		ifTrue: [ ^ MalNil new ].	arg class = MalString		ifTrue: [ ^ MalList				withValue:					(arg value						collect: [ :c | MalString withValue: c asString ]						into: OrderedCollection new) ].	^ MalNil new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSeq class	instanceVariableNames: ''!!MalSeq class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 16:52'!malName	^ 'seq'! !MalFunctionOneArg subclass: #MalSequentialPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSequentialPredicate commentStamp: 'WilfredHughes 6/15/2019 22:07' prior: 0!I represent the sequential? function.!!MalSequentialPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 22:07'!callArg: arg withContext: ctx	^ MalBool withValue: arg isIterable ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSequentialPredicate class	instanceVariableNames: ''!!MalSequentialPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 22:07'!malName	^ 'sequential?'! !MalFunctionOneArg subclass: #MalSlurp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSlurp commentStamp: 'WilfredHughes 6/2/2019 23:49' prior: 0!I represent the slurp built-in function in MAL.!!MalSlurp methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 23:50'!callArg: arg withContext: ctx	arg class = MalString		ifFalse: [ ^ MalError signal: 'Expected a string' ].	^ MalString withValue: (arg value asFileReference readStream upToEnd)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSlurp class	instanceVariableNames: ''!!MalSlurp class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 00:00'!malName	^ 'slurp'! !MalFunction subclass: #MalStr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStr commentStamp: 'WilfredHughes 6/3/2019 20:53' prior: 0!I represent the str built-in function in MAL.!!MalStr methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 21:56'!call: args withContext: ctx	| stringArgs |	stringArgs := args collect: #asString.	^ MalString withValue: ('' join: stringArgs)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStr class	instanceVariableNames: ''!!MalStr class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 20:56'!malName	^ 'str'! !MalType subclass: #MalString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalString commentStamp: 'WilfredHughes 5/5/2019 10:05' prior: 0!I represent string values in MAL.!!MalString methodsFor: 'accessing' stamp: 'WilfredHughes 6/6/2019 09:52'!asReadableString	| inner |	inner := self value copyReplaceAll: '\' with: '\\'.	inner := inner		copyReplaceAll:			Character lf asString		with: '\n'.	inner := inner copyReplaceAll: '"' with: '\"'.	^ '"' , inner , '"'! !!MalString methodsFor: 'converting' stamp: 'WilfredHughes 6/3/2019 21:54'!asString ^ value! !MalFunctionOneArg subclass: #MalStringPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStringPredicate commentStamp: 'WilfredHughes 6/23/2019 00:48' prior: 0!I represent the string? function.!!MalStringPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 00:48'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStringPredicate class	instanceVariableNames: ''!!MalStringPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 00:49'!malName	^ 'string?'! !MalFunction subclass: #MalSubtract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSubtract commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function - in MAL.!!MalSubtract methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 00:47'!call: args withContext: ctx	"Subtract args."	| total |	self ensure: args haveType: MalInteger.	args ifEmpty: [ ^ MalInteger withValue: 0 ].	args size = 1		ifTrue: [ ^ MalInteger withValue: args first value negated ].	total := args first value.	args allButFirst do: [ :arg | total := total - arg value ].	^ MalInteger withValue: total! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSubtract class	instanceVariableNames: ''!!MalSubtract class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:40'!malName^ '-'! !MalFunction subclass: #MalSwap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSwap commentStamp: 'WilfredHughes 6/4/2019 19:33' prior: 0!I represent the swap!! function in MAL.!!MalSwap methodsFor: 'evaluating' stamp: 'WilfredHughes 6/25/2019 09:43'!call: args withContext: ctx	| atom func funcArgs newValue |		self ensure: args haveMinArity: 2.	atom := args first.	atom class = MalAtom		ifFalse: [ MalError signal: 'first argument to swap!! must be an atom' ].	func := args second.	func isCallable		ifFalse: [ MalError signal: 'second argument to swap!! must be a function' ].	funcArgs := OrderedCollection with: atom value.	funcArgs addAll: (args allButFirst: 2).	newValue := func call: funcArgs withContext: ctx.	atom value: newValue.	^ newValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSwap class	instanceVariableNames: ''!!MalSwap class methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 19:42'!malName	^ 'swap!!'! !MalType subclass: #MalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!MalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ value! !!MalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 6/21/2019 10:14'!evalIn: ctx	ctx env		at: self value		ifPresent: [ :currentValue | ^ currentValue ]		ifAbsent:			[ MalUnboundSymbol signal: '''' , self value , ''' not found' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSymbol class	instanceVariableNames: ''!!MalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !MalFunctionOneArg subclass: #MalSymbolFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSymbolFunction commentStamp: 'WilfredHughes 6/17/2019 23:16' prior: 0!I represent the symbol function.!!MalSymbolFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:17'!callArg: arg withContext: ctx	arg class = MalString		ifFalse: [ MalError signal: 'symbol requires a string argument' ].	^ MalSymbol withValue: arg value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSymbolFunction class	instanceVariableNames: ''!!MalSymbolFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 23:17'!malName	^ 'symbol'! !MalFunctionOneArg subclass: #MalSymbolPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSymbolPredicate commentStamp: 'WilfredHughes 6/17/2019 23:03' prior: 0!I represent the symbol? function.!!MalSymbolPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:04'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalSymbol! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSymbolPredicate class	instanceVariableNames: ''!!MalSymbolPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 23:03'!malName	^ 'symbol?'! !MalFunctionOneArg subclass: #MalThrow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalThrow commentStamp: 'WilfredHughes 6/20/2019 09:48' prior: 0!I represent the built-in throw function.!!MalThrow methodsFor: 'evaluating' stamp: 'WilfredHughes 6/20/2019 09:49'!callArg: arg withContext: ctx	MalError signal: 'Exception: ' , arg asReadableString  withTag: arg! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalThrow class	instanceVariableNames: ''!!MalThrow class methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 21:59'!malName	^ 'throw'! !MalFunction subclass: #MalTimeMs	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalTimeMs commentStamp: 'WilfredHughes 6/23/2019 01:00' prior: 0!I represent the time-ms function.!!MalTimeMs methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 01:00'!call: args withContext: ctx	| now milliseconds |	self ensure: args haveArity: 0.	now := DateAndTime now asUTC.	milliseconds := (now second * 1000) + (now nanoSecond // 1000000).	^ MalInteger withValue: milliseconds! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalTimeMs class	instanceVariableNames: ''!!MalTimeMs class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 01:00'!malName	^ 'time-ms'! !MalFunctionOneArg subclass: #MalTruePredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalTruePredicate commentStamp: 'WilfredHughes 6/17/2019 23:07' prior: 0!I represent the true? function.!!MalTruePredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:10'!callArg: arg withContext: ctx	^ MalBool withValue: (arg = (MalBool withValue: true))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalTruePredicate class	instanceVariableNames: ''!!MalTruePredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 23:08'!malName	^ 'true?'! !MalError subclass: #MalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!MalFunctionOneArg subclass: #MalVals	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalVals commentStamp: 'WilfredHughes 6/17/2019 23:02' prior: 0!I represent the vals function.!!MalVals methodsFor: 'evaluating' stamp: 'WilfredHughes 6/17/2019 23:02'!callArg: arg withContext: ctx	arg class = MalHashMap		ifFalse: [ MalError signal: 'vals requires a hash map argument' ].	^ MalList withValue: (OrderedCollection newFrom: arg value values)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalVals class	instanceVariableNames: ''!!MalVals class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 23:02'!malName	^ 'vals'! !MalType subclass: #MalVector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalVector commentStamp: 'WilfredHughes 5/29/2019 10:30' prior: 0!I represent vectors [ 1 2 3 ] in MAL.!!MalVector methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/9/2019 01:20'!allButFirst	^ self class withValue: (self value allButFirst: 1)! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 5/30/2019 09:56'!evalIn: ctx	"A vector evaluates all its elements."	^ MalVector		withValue: (self value collect: [ :item | item evalIn: ctx ])! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/9/2019 01:18'!isPair	^ self value isNotEmpty! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	| inner |	inner := ' ' join: (value collect: #asReadableString).	^ '[' , inner , ']'! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:00'!isIterable^ true! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:10'!asString	| inner |	inner := ' ' join: (value collect: #asString).	^ '[' , inner , ']'! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:30'!size	^ value size! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/24/2019 09:56'!initialize value := OrderedCollection new! !MalFunction subclass: #MalVectorFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalVectorFunction commentStamp: 'WilfredHughes 6/15/2019 22:05' prior: 0!I represent the vector function.!!MalVectorFunction methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 22:05'!call: args withContext: ctx	^ MalVector withValue: args! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalVectorFunction class	instanceVariableNames: ''!!MalVectorFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/15/2019 22:05'!malName	^ 'vector'! !MalFunctionOneArg subclass: #MalVectorPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalVectorPredicate commentStamp: 'WilfredHughes 6/15/2019 22:05' prior: 0!I represent the vector? function.!!MalVectorPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/15/2019 22:05'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalVector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalVectorPredicate class	instanceVariableNames: ''!!MalVectorPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/17/2019 09:51'!malName	^ 'vector?'! !MalFunction subclass: #MalWithMeta	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalWithMeta commentStamp: 'WilfredHughes 6/23/2019 15:35' prior: 0!I represent the with-meta function.!!MalWithMeta methodsFor: 'evaluating' stamp: 'WilfredHughes 6/23/2019 15:45'!call: args withContext: ctx	| newVal |	self ensure: args haveArity: 2.	newVal := args first copy.	newVal meta: args second.	^ newVal! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalWithMeta class	instanceVariableNames: ''!!MalWithMeta class methodsFor: 'accessing' stamp: 'WilfredHughes 6/23/2019 15:36'!malName	^ 'with-meta'! !MalError subclass: #MalWrongArity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalWrongArity commentStamp: 'WilfredHughes 5/18/2019 15:43' prior: 0!Error when calling functions with the wrong number of arguments.!