Object subclass: #WMal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMal commentStamp: 'WilfredHughes 5/7/2019 23:46' prior: 0!I am a Make-A-Lisp (MAL) interpreter.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMal class	instanceVariableNames: ''!!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:56'!eval: aForm in: env	^ aForm evalIn: env! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/9/2019 10:01'!defaultEnv	^ WMalEnv new	at: 'def!!' put: WMalDef new;		at: '+' put: WMalAdd new;		at: '-' put: WMalSubtract new;		at: '*' put: WMalMultiply new;		at: '/' put: WMalDivide new;		yourself! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 3/13/2018 08:48'!demo	| val env |	val := WMal read: '(/ (+ 5 6) 2)'.	env := WMal defaultEnv.	^ val evalIn: env! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:52'!rep: aString^ self rep: aString in: (self defaultEnv )! !!WMal class methodsFor: 'printing' stamp: 'WilfredHughes 11/5/2017 22:44'!print: aValue	^ aValue print! !!WMal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 11/5/2017 22:45'!read: aString	^ WMalReader readString: aString! !Object subclass: #WMalEnv	instanceVariableNames: 'bindings outer'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalEnv commentStamp: 'WilfredHughes 5/8/2019 09:58' prior: 0!I represent environments in MAL. I look up symbols, and can defer toouter environments if a symbol isn't present in my bindings.My API roughly follows Dictionary.!!WMalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/8/2019 10:05'!at: key ifPresent: presentBlock ifAbsent: absentBlock	^ bindings		at: key		ifPresent: [ :value | ^ presentBlock cull: value ]		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifPresent: presentBlock ifAbsent: absentBlock ]				ifNil: [ absentBlock value ] ]! !!WMalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/8/2019 09:55'!at: key	^ self at: key ifAbsent: [ WMalUnboundSymbol signal: 'Unbound variable: ' , key ]! !!WMalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/8/2019 09:56'!at: key ifAbsent: aBlock	^ bindings		at: key		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifAbsent: aBlock ]				ifNil: [ aBlock value ] ]! !!WMalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:56'!at: key put: value	"Insert this key at this level"	bindings at: key put: value! !!WMalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:56'!bindings: aDictionary	bindings := aDictionary! !!WMalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:57'!outer: aLinkedDictionary	outer := aLinkedDictionary! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalEnv class	instanceVariableNames: ''!!WMalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/8/2019 10:08'!new	^ super new		bindings: Dictionary new;		yourself! !!WMalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 11/9/2017 19:17'!withNext: env	^ self		new		next: env;		yourself! !Error subclass: #WMalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!TestCase subclass: #WMalListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalListTest commentStamp: 'WilfredHughes 11/2/2017 08:46' prior: 0!Testing methods on WMalList.!!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:42'!testEval	"Evaluate a list."	| val env |	val := WMal read: '(+ 1 (+ 2 3))'.	env := Dictionary new		at: '+' put: WMalAdd new;		yourself.	self assert: (val evalIn: env) equals: (WMalInteger withValue: 6)! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:19'!testEvalEmpty"Empty list should evaluate to itself."	| val items |	items := OrderedCollection new.	val := WMalList withValue: items.	self assert: (val evalIn: nil) equals: val! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:48'!testPrint	| val first second items |	first := WMalInteger withValue: 1.	second := WMalInteger withValue: 2.	items := OrderedCollection with: first with: second.	val := WMalList withValue: items.		self assert: val print equals: '(1 2)'! !WMalError subclass: #WMalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!Object subclass: #WMalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalReader commentStamp: 'WilfredHughes 3/25/2018 13:08' prior: 0!I convert MAL source code to an AST instance of WMalType.I return an OrderedCollection of forms read.To get started, use #readString:WMalReader readString: '(+ 1 2').!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalReader class	instanceVariableNames: ''!!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:36'!readForm: aTokenStream	| current |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream ]		ifFalse: [ ^ self readAtom: aTokenStream ]! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/6/2019 18:40'!readAtom: aStream	"Parse a single mal type."	| token firstChar |	token := aStream next.	token ifNil: [ WMalSyntaxError signal: 'Missing )' ].	firstChar := token first: 1.	token = ')'		ifTrue: [ WMalSyntaxError signal: 'Unexpected )' ].	token isAllDigits		ifTrue: [ ^ WMalInteger withValue: token asInteger ].	firstChar = '-' & token allButFirst isAllDigits		ifTrue: [ ^ WMalInteger withValue: token allButFirst asInteger negated ].	token = 'nil'		ifTrue: [ ^ WMalNil new ].	token = 'true'		ifTrue: [ ^ WMalBool withValue: true ].	token = 'false'		ifTrue: [ ^ WMalBool withValue: false ].	"TODO: Check for a closing double-quote on string literals."	firstChar = '"'		ifTrue: [ ^ WMalString withValue: (self stringContents: token) ].	^ WMalSymbol withValue: token! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 3/25/2018 16:07'!readList: aTokenStream	| items current finished |	items := OrderedCollection new.	finished := false.	[ finished ]		whileFalse: [ current := aTokenStream peek.				current = ')'				ifTrue: [ finished := true.					aTokenStream next ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	self assert: current = ')' description: 'Unclosed ('.	^ WMalList withValue: items! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/6/2019 01:15'!stringContents: token	| tok |	"Remove the double quotes and unescape a string literal."	tok := token copyReplaceAll: '\\' with: '\'.	tok := tok copyReplaceAll: '\"' with: '"'.	^ tok allButFirst allButLast! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/7/2019 22:58'!readString: aString	"Lex and parse a string of MAL source code. 	Return a collection of tokens."	| parsed tokens stream |	parsed := OrderedCollection new.	tokens := (WMalTokenizer fromString: aString).	stream := tokens readStream.	^ self readForm: stream! !CommandLineHandler subclass: #WMalStep	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalStep commentStamp: 'WilfredHughes 4/29/2019 10:05' prior: 0!I am the base class for all Mal command line handlers. I write a prompt, read input from the user, then dispatch.!!WMalStep methodsFor: 'activation' stamp: 'WilfredHughes 5/7/2019 23:35'!activate	| input |	input := self readInputLine.	[ input isEmptyOrNil ]		whileFalse: [ 			self stdout				<< (self rep: input) asString;				lf.			input := self readInputLine ].	self stdout lf.	self exitSuccess! !!WMalStep methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:08'!readInputLine	self stdout << 'user> '.	^ (Stdio stdin upTo: Character lf asInteger) asString! !!WMalStep methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:14'!rep: aString	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalStep class	instanceVariableNames: ''!!WMalStep class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:17'!commandName	^ ''! !WMalStep subclass: #WMalStep0	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalStep0 commentStamp: 'WilfredHughes 4/29/2019 10:03' prior: 0!I am the simplest Mal REPL, simply echoing my input to the user.!!WMalStep0 methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:16'!rep: aString	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalStep0 class	instanceVariableNames: ''!!WMalStep0 class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:15'!commandName	^ 'step0_mal'! !WMalStep subclass: #WMalStep1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalStep1 commentStamp: 'WilfredHughes 5/7/2019 23:46' prior: 0!I am a simple Mal REPL, parsing then printing my input.!!WMalStep1 methodsFor: 'activation' stamp: 'WilfredHughes 5/8/2019 00:02'!rep: aString	^ [WMal print: (WMal read: aString)] on: WMalError do: [ :ex | ex messageText  ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalStep1 class	instanceVariableNames: ''!!WMalStep1 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 01:19'!commandName	^ 'step1_mal'! !WMalStep subclass: #WMalStep2	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalStep2 commentStamp: 'WilfredHughes 5/7/2019 23:45' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image wmal 2>/dev/null!!WMalStep2 methodsFor: 'activation' stamp: 'WilfredHughes 5/10/2019 10:02'!env: aMalEnv	env := aMalEnv ! !!WMalStep2 methodsFor: 'activation' stamp: 'WilfredHughes 5/10/2019 10:03'!rep: aString	^ [ WMal rep: aString in: env ]		on: WMalError		do: [ :ex | ex messageText ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalStep2 class	instanceVariableNames: 'env'!!WMalStep2 class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/10/2019 10:00'!new	^ super new		env: WMal defaultEnv ;		yourself! !!WMalStep2 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/7/2019 23:47'!commandName	^ 'step2_mal'! !WMalError subclass: #WMalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #WMalTokenizer	instanceVariableNames: ''	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'MakeALisp'!!WMalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalTokenizer class	instanceVariableNames: ''!!WMalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/7/2019 22:53'!fromString: aString	"Return a collection of all the tokens in our string."	| pattern matcher result |	"This isn't exactly the same as the MAL docs.   We are forced to treat [ and ] separately due to syntax limitations   in the regex engine, and we ban newlines in comments."	pattern := '[\s,]*(~@|\[|[]{}()''`~^@]|"(\\.|[^\\"])*"|;[^]*|(\[|\]|[^\s{}(''"`,;)])*)'.	matcher := RxMatcher forString: pattern.	result := matcher		matchesOnStream: aString readStream		collect: [ :s | matcher subexpression: 2 ].	^ result reject: [ :str | str isEmpty or: [ str first = $; ] ]! !Object subclass: #WMalType	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalType commentStamp: 'WilfredHughes 8/27/2017 18:04' prior: 0!I am the base class for all MAL types.!!WMalType methodsFor: 'comparing' stamp: 'WilfredHughes 9/1/2017 19:13'!= anObject	self class = anObject class		ifTrue: [ ^ value = (anObject value) ]		ifFalse: [ ^ false ]! !!WMalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 3/13/2018 08:40'!evalIn: env"Default behaviour is types evaluate to themselves."	^ self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value: anInteger	value := anInteger.	^self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 5/9/2019 09:53'!call: args withEnv: anEnviroment	"Try to call this value as a function."	WMalNotCallable signal: 'Not a function: ' , self print! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 3/5/2019 09:39'!print	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalType class	instanceVariableNames: ''!!WMalType class methodsFor: 'initialization' stamp: 'WilfredHughes 9/4/2017 08:30'!withValue: aNumber	| instance |	instance := self new.	instance value: aNumber.	^ instance! !WMalType subclass: #WMalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!WMalBool methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:22'!print	^ self value asString! !WMalType subclass: #WMalCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalCallable commentStamp: 'WilfredHughes 3/25/2018 12:33' prior: 0!I represent anything that can be called in Mal: both functions and special forms.!!WMalCallable methodsFor: 'accessing' stamp: 'WilfredHughes 3/25/2018 12:44'!call: args withEnv: anObject	self subclassResponsibility ! !!WMalCallable methodsFor: 'accessing' stamp: 'WilfredHughes 3/5/2019 09:40'!print	^ '#<callable>'! !WMalCallable subclass: #WMalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalFunction commentStamp: 'WilfredHughes 11/5/2017 23:29' prior: 0!I represent callable values in MAL. Currently just built-in functions.!WMalFunction subclass: #WMalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalAdd commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function + in MAL.!!WMalAdd methodsFor: 'accessing' stamp: 'WilfredHughes 3/25/2018 12:44'!call: args withEnv: anObject	"Add args together. TODO: type errors."	| total |	total := 0.	args do: [ :arg | total := total + arg value ].	^ WMalInteger withValue: total! !WMalFunction subclass: #WMalDivide	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalDivide commentStamp: 'WilfredHughes 11/6/2017 19:01' prior: 0!The built-in function / in MAL.!!WMalDivide methodsFor: 'accessing' stamp: 'WilfredHughes 3/25/2018 12:44'!call: args withEnv: anObject	"Divide args together. TODO: type errors, arity errors"	| result |	result := args first value.	args allButFirstDo: [ :arg | result := result // arg value ].	^ WMalInteger withValue: result! !WMalType subclass: #WMalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!WMalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:17'!print	^ self value asString! !WMalType subclass: #WMalKeyword	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalKeyword commentStamp: 'WilfredHughes 3/13/2018 08:30' prior: 0!I represent keywords  in MAL.Keywords are symbols that start with :, e.g. :foo.Keywords evaluate to themselves.!!WMalKeyword methodsFor: 'accessing' stamp: 'WilfredHughes 3/13/2018 08:29'!print	^ ':', value! !WMalType subclass: #WMalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalList commentStamp: 'WilfredHughes 9/26/2017 19:27' prior: 0!I represent a list value in MAL.!!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 5/10/2019 09:51'!evalIn: env	| items evalledItems func |	items := self value.	"Empty list evaluates to itself"	items ifEmpty: [ ^ self ].	"def!! takes two arguments, and evaluates the second."	items first value = 'def!!' ifTrue: [ ^ self evalDef: items in: env ].	"Evaluate all the items in the list, then call the first arg with the rest."	evalledItems := items collect: [ :item | item evalIn: env ].	func := evalledItems first.	^ func call: evalledItems allButFirst withEnv: nil! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:49'!print   | inner |inner := ' ' join: (value collect: #print).^ '(', inner, ')'! !!WMalList methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/10/2019 09:57'!evalDef: args in: env 	| sym val |	args size = 3 ifFalse: [ WMalError signal: 'Wrong number of arguments to def!!' ].	sym := args second.	sym class = WMalSymbol ifFalse: [ WMalError signal: 'The first argument to def!! must be a symbol' ].	val := args third evalIn: env.	env at: sym value put: val.	^ val! !WMalFunction subclass: #WMalMultiply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalMultiply commentStamp: 'WilfredHughes 11/6/2017 18:57' prior: 0!The built-in function * in MAL.!!WMalMultiply methodsFor: 'accessing' stamp: 'WilfredHughes 3/25/2018 12:44'!call: args withEnv: anObject	"Multiply args together. TODO: type errors."	| total |	total := 1.	args do: [ :arg | total := total * arg value ].	^ WMalInteger withValue: total! !WMalType subclass: #WMalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!WMalNil methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:38'!print	^ 'nil'! !!WMalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 14:44'!printOn: aStream	aStream		nextPutAll: 'a WMalNil'! !WMalCallable subclass: #WMalSpecialForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalSpecialForm commentStamp: 'WilfredHughes 3/25/2018 12:35' prior: 0!I represent callables in Mal that don't evaluate all their arguments.!WMalSpecialForm subclass: #WMalDef	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalDef commentStamp: 'WilfredHughes 3/25/2018 12:38' prior: 0!I set variables in the current environment.!!WMalDef methodsFor: 'accessing' stamp: 'WilfredHughes 5/9/2019 10:01'!call: args withEnv: anObject	^ WMalError signal: 'calling def!!'! !WMalType subclass: #WMalString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalString commentStamp: 'WilfredHughes 5/5/2019 10:05' prior: 0!I represent string values in MAL.!!WMalString methodsFor: 'accessing' stamp: 'WilfredHughes 5/8/2019 00:10'!print   |inner|   	inner := self value copyReplaceAll: '\' with: '\\'.	inner := inner copyReplaceAll: '"' with: '\"'.	^ '"' , inner , '"'! !WMalFunction subclass: #WMalSubtract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalSubtract commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function - in MAL.!!WMalSubtract methodsFor: 'accessing' stamp: 'WilfredHughes 3/25/2018 12:44'!call: args withEnv: anObject	"Subtract args. TODO: type errors."	| total |	args ifEmpty: [ ^ WMalInteger withValue: 0 ].	args size = 1		ifTrue: [ ^ WMalInteger withValue: args first value negated ].	total := args first value.	args allButFirst do: [ :arg | total := total - arg value ].	^ WMalInteger withValue: total! !WMalType subclass: #WMalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:11'!evalIn: env	env at: self value ifPresent: [ :currentValue | ^currentValue ] ifAbsent: [ WMalUnboundSymbol signal: 'Unbound variable: ' , self value ]! !!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:54'!print	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalSymbol class	instanceVariableNames: ''!!WMalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !WMalError subclass: #WMalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!WMalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!TestCase subclass: #WMalBoolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalBoolTest commentStamp: 'WilfredHughes 11/1/2017 00:21' prior: 0!I test methods on WMalBool objects.!!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 22:59'!testEvalIn	| val |	val := WMalBool withValue: false.	self assert: (val evalIn: nil) equals: val! !!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:21'!testPrint| val|val := WMalBool withValue: false.self assert: (val print) equals: 'false'.! !TestCase subclass: #WMalDivideTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalDivideTest commentStamp: '<historical>' prior: 0!A WMalDivideTest is a test class for testing the behavior of WMalDivide!!WMalDivideTest methodsFor: 'tests-accessing' stamp: 'WilfredHughes 3/25/2018 12:45'!testCall	| args |	args := OrderedCollection		with: (WMalInteger withValue: 11)		with: (WMalInteger withValue: 5).	self		assert: (WMalDivide new call: args withEnv: nil)		equals: (WMalInteger withValue: 2)! !TestCase subclass: #WMalEnvTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalEnvTest commentStamp: 'WilfredHughes 5/8/2019 09:53' prior: 0!A WMalEnvTest is a test class for testing the behavior of WMalEnv.!!WMalEnvTest methodsFor: 'tests-setter' stamp: 'WilfredHughes 5/8/2019 09:52'!testAtIfAbsent	| dict |	dict := WMalEnv new.	dict at: 'foo' put: 123.	self assert: (dict at: 'foo') equals: 123! !TestCase subclass: #WMalIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalIntegerTest commentStamp: '<historical>' prior: 0!A WMalIntegerTest is a test class for testing the behavior of WMalInteger!!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 18:56'!testEquality	"Ensure = works as expected."	| int1a int1b int2 |	int1a := WMalInteger withValue: 1.	int1b := WMalInteger withValue: 1.	int2 := WMalInteger withValue: 2.	self assert: int1a = int1b.	self assert: int1a ~= int2! !!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:20'!testPrint	"Ensure we can convert to a printable representation."	| int |	int := WMalInteger withValue: 123.	self assert: int print equals: '123'! !TestCase subclass: #WMalKeywordTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalKeywordTest methodsFor: 'tests' stamp: 'WilfredHughes 3/13/2018 08:32'!testEquality	"Ensure = works as expected."	| k1 k2 |	k1 := WMalKeyword withValue: 'foo'.	k2 := WMalKeyword withValue: 'bar'.	self assert: k1 = k1.	self assert: k1 ~= k2! !!WMalKeywordTest methodsFor: 'tests' stamp: 'WilfredHughes 3/13/2018 08:27'!testPrint	"Ensure we can convert to a printable representation."	| symValue |	symValue := WMalKeyword withValue: 'foo'.	self assert: symValue print equals: ':foo'! !TestCase subclass: #WMalMultiplyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalMultiplyTest commentStamp: '<historical>' prior: 0!A WMalMultiplyTest is a test class for testing the behavior of WMalMultiply!!WMalMultiplyTest methodsFor: 'tests' stamp: 'WilfredHughes 3/25/2018 12:44'!testCall	| args |	args := OrderedCollection		with: (WMalInteger withValue: 2)		with: (WMalInteger withValue: 3).	self		assert: (WMalMultiply new call: args withEnv: nil)		equals: (WMalInteger withValue: 6)! !TestCase subclass: #WMalNilTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 3/13/2018 11:36'!testEvalIn	| nilValue |	nilValue := WMalNil new.	self assert: (nilValue evalIn: nil) equals: nilValue! !!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:38'!testPrint	"Ensure we can convert to a printable representation."	| nilValue |	nilValue := WMalNil new.	self assert: nilValue print equals: 'nil'! !TestCase subclass: #WMalReaderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalReaderTest commentStamp: '<historical>' prior: 0!A WMalReaderTest is a test class for testing the behavior of WMalReader!!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 5/6/2019 14:40'!testReadAtomSymbol	| parsed expected stream |	stream := (OrderedCollection with: 'abc-def3') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalSymbol withValue: 'abc-def3'.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:42'!testReadAtomNil	| parsed expected stream |	stream := (OrderedCollection with: 'nil') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalNil new.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 19:05'!testReadAtom	| parsed expected stream |	stream := (OrderedCollection with: '123') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalInteger withValue: 123.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 5/5/2019 10:08'!testReadAtomString	| parsed expected stream |	stream := (OrderedCollection with: '"foo"') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalString withValue: 'foo'.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:12'!testReadAtomFalse	| parsed expected stream |	stream := (OrderedCollection with: 'false') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: false.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnclosed	self should: [ WMalReader readString: '(' ] raise: WMalSyntaxError! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 5/6/2019 14:46'!testReadStringWithComment	| parsed |	parsed := WMalReader readString: ';foo123'.	self assert: parsed equals: (WMalInteger withValue: 123)! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:36'!testReadString	| parsed |	parsed := WMalReader readString: '123'.	self assert: parsed equals: (WMalInteger withValue: 123)! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnopened"todo: We don't consider foo) to be a syntax error because we only read one form."	self should: [WMalReader readString: ')'] raise: WMalSyntaxError.! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:46'!testReadAtomTrue	| parsed expected stream |	stream := (OrderedCollection with: 'true') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: true.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 5/6/2019 01:23'!testReadAtomNegativeNumber	| parsed expected stream |	stream := (OrderedCollection with: '-123') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalInteger withValue: -123.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/26/2017 19:39'!testReadForm	| parsed expectedItems |	parsed := WMalReader readString: '(1 2)'.	self assert: parsed class equals: WMalList.	expectedItems := OrderedCollection with: (WMalInteger withValue: 1) with: (WMalInteger withValue: 2).	self assert: parsed value equals: expectedItems! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 5/6/2019 01:13'!testReadAtomStringWithEscapes	| parsed expected stream |	stream := (OrderedCollection with: '"foo\\bar\"baz"') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalString withValue: 'foo\bar"baz'.	self assert: parsed equals: expected! !TestCase subclass: #WMalStringTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalStringTest methodsFor: 'tests' stamp: 'WilfredHughes 5/8/2019 00:10'!testPrint	| string |	string := WMalString withValue: 'foo"bar\baz'.	self assert: string print equals: '"foo\"bar\\baz"'! !TestCase subclass: #WMalSubtractTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalSubtractTest commentStamp: '<historical>' prior: 0!A WMalSubtractTest is a test class for testing the behavior of WMalSubtract!!WMalSubtractTest methodsFor: 'tests' stamp: 'WilfredHughes 11/6/2017 00:00'!testCall	| sexp |	sexp := WMal read: '(- 3 2)'.	self		assert: (sexp evalIn: WMal defaultEnv)		equals: (WMalInteger		withValue: 1)! !TestCase subclass: #WMalSymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:10'!testEvalIn	"Test that we lookup values in the environment."	| fooSym env one |	fooSym := WMalSymbol withValue: 'foo'.	one := WMalInteger withValue: 1.	env := Dictionary new		at: 'foo' put: one;		yourself.	self assert: (fooSym evalIn: env) equals: one! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:03'!testEvalInUnbound	"Test that we error on unbound symbols."	| fooSym env |	fooSym := WMalSymbol withValue: 'foo'.	env := Dictionary new.	self should: [ fooSym evalIn: env ] raise: WMalUnboundSymbol ! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:53'!testPrint	"Ensure we can convert to a printable representation."	| symValue |	symValue := WMalSymbol withValue: 'foo'.	self assert: symValue print equals: 'foo'! !TestCase subclass: #WMalTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalTest commentStamp: '<historical>' prior: 0!A WMalTest is a test class for testing the behavior of WMal!!WMalTest methodsFor: 'tests' stamp: 'WilfredHughes 3/25/2018 12:28'!testEvalIn	| val env |	val := WMal read: '(+ (* 2 3) 1)'.	env := WMal defaultEnv.	self assert: (val evalIn: env) equals: (WMalInteger withValue: 7) 		! !!WMalTest methodsFor: 'tests' stamp: 'WilfredHughes 5/9/2019 10:00'!testDef	| env defExpr |	defExpr := WMal read: '(def!! x 42)'.	env := WMal defaultEnv.	defExpr evalIn: env.	self		assert: ((WMalSymbol withValue: 'x') evalIn: env)		equals: (WMalInteger withValue: 42)! !TestCase subclass: #WMalTokenizerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp-Tests'!!WMalTokenizerTest commentStamp: 'WilfredHughes 8/27/2017 17:23' prior: 0!A WMalTokenizerTest is a test class for testing the behavior of WMalTokenizer.!!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 5/7/2019 22:55'!testFromStringNewline	| tokens expected |	tokens := WMalTokenizer fromString: 'foobar'.	expected := OrderedCollection with: 'foo' with: 'bar'.	self assert: tokens equals: expected! !!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 5/7/2019 22:56'!testFromStringWithComment	| tokens expected |	tokens := WMalTokenizer		fromString:			'; a comment			foo ; another commentbar; more comment'.	expected := OrderedCollection with: 'foo' with: 'bar'.	self assert: tokens equals: expected! !!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 5/7/2019 23:23'!testFromStringCommas	| tokens expected |	tokens := WMalTokenizer fromString: ' ,,foo ,'.	expected := OrderedCollection with: 'foo'.	self assert: tokens equals: expected! !!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 5/7/2019 22:54'!testFromString	| tokens expected |	tokens := WMalTokenizer fromString: ' foo bar'.	expected := OrderedCollection with: 'foo' with: 'bar'.	self assert: tokens equals: expected! !