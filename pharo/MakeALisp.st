Object subclass: #Mal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!Mal commentStamp: 'WilfredHughes 5/7/2019 23:46' prior: 0!I am a Make-A-Lisp (MAL) interpreter.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mal class	instanceVariableNames: ''!!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:56'!eval: aForm in: env	^ aForm evalIn: env! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/23/2019 10:26'!defaultEnv	^ MalEnv new		at: (MalSymbol withValue: '+') put: MalAdd new;		at: (MalSymbol withValue: '-') put: MalSubtract new;		at: (MalSymbol withValue: '*') put: MalMultiply new;		at: (MalSymbol withValue: '/') put: MalDivide new;		at: (MalSymbol withValue: 'list') put: MalListFunction new;		at: (MalSymbol withValue: 'list?') put: MalListPredicate new;		at: (MalSymbol withValue: 'empty?') put: MalEmptyPredicate new;		at: (MalSymbol withValue: 'count') put: MalCount new;		at: (MalSymbol withValue: '>') put: MalGreaterThan new;		at: (MalSymbol withValue: '>=') put: MalGreaterThanOrEqual new;		at: (MalSymbol withValue: '<') put: MalLessThan new;		at: (MalSymbol withValue: '<=') put: MalLessThanOrEqual new;			at: (MalSymbol withValue: 'prn') put: MalPrn new;		yourself! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/14/2019 09:59'!demo	| val env |	val := Mal read: '(/ (+ 5 6) 2)'.	env := Mal defaultEnv.	^ val evalIn: env! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:52'!rep: aString^ self rep: aString in: (self defaultEnv )! !!Mal class methodsFor: 'printing' stamp: 'WilfredHughes 11/5/2017 22:44'!print: aValue	^ aValue print! !!Mal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 5/14/2019 10:01'!read: aString	^ MalReader readString: aString! !Object subclass: #MalContext	instanceVariableNames: 'env stdout'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalContext commentStamp: 'WilfredHughes 5/25/2019 11:23' prior: 0!I represent the state needed to evaluate MAL expressions.!!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:40'!withEnv: newEnv"Return a copy of self with a different environment."	^ self class		new		env: newEnv;		stdout: stdout;		yourself! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!stdout: anObject	stdout := anObject! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:39'!env: bindings	env := bindings! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!env	^ env! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!stdout	^ stdout! !Object subclass: #MalEnv	instanceVariableNames: 'bindings outer stdout'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEnv commentStamp: 'WilfredHughes 5/22/2019 10:28' prior: 0!I represent environments in MAL. I look up symbols, and can defer toouter environments if a symbol isn't present in my bindings.My API roughly follows Dictionary.I also hold references to Smalltalk objects that MAL needs, such as stdout.!!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:05'!at: aSymbol ifPresent: presentBlock ifAbsent: absentBlock	| key |	key := aSymbol value.	^ bindings		at: key		ifPresent: [ :value | ^ presentBlock cull: value ]		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifPresent: presentBlock ifAbsent: absentBlock ]				ifNil: [ absentBlock value ] ]! !!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:05'!at: aSymbol ifAbsent: aBlock	| key |	key := aSymbol value.	^ bindings		at: key		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifAbsent: aBlock ]				ifNil: [ aBlock value ] ]! !!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:12'!at: aSymbol	| key |	self		assert: [ aSymbol class = MalSymbol ]		description: 'env keys should be symbols'.	key := aSymbol value.	^ self		at: key		ifAbsent: [ MalUnboundSymbol signal: 'Unbound variable: ' , key ]! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/22/2019 10:12'!at: aSymbol put: value	"Insert this symbol at this level"	| key |		self		assert: [ aSymbol class = MalSymbol ]		description: 'env keys should be symbols'.	key := aSymbol value.	bindings at: key put: value! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:57'!outer: aLinkedDictionary	outer := aLinkedDictionary! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:56'!bindings: aDictionary	bindings := aDictionary! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEnv class	instanceVariableNames: ''!!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/8/2019 10:08'!new	^ super new		bindings: Dictionary new;		yourself! !!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/25/2019 11:57'!withOuter: env	self		assert: [ env class = self ]		description: [ 'Outer env class should match this env' ].	^ self new		outer: env;		yourself! !Error subclass: #MalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!MalError subclass: #MalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!Object subclass: #MalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReader commentStamp: 'WilfredHughes 5/25/2019 00:49' prior: 0!I convert MAL source code to an AST instance of WMalType.I return an OrderedCollection of forms read.To get started, use #readString:MalReader readString: '(+ 1 2)'.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReader class	instanceVariableNames: ''!!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:36'!readForm: aTokenStream	| current |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream ]		ifFalse: [ ^ self readAtom: aTokenStream ]! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/20/2019 00:47'!readAtom: aStream	"Parse a single mal type."	| token firstChar |	token := aStream next.	token ifNil: [ MalSyntaxError signal: 'Missing )' ].	firstChar := token first: 1.	token = ')'		ifTrue: [ MalSyntaxError signal: 'Unexpected )' ].	token isAllDigits		ifTrue: [ ^ MalInteger withValue: token asInteger ].	firstChar = '-' & token allButFirst isAllDigits		ifTrue: [ ^ MalInteger withValue: token allButFirst asInteger negated ].	token = 'nil'		ifTrue: [ ^ MalNil new ].	token = 'true'		ifTrue: [ ^ MalBool withValue: true ].	token = 'false'		ifTrue: [ ^ MalBool withValue: false ].	"TODO: Check for a closing double-quote on string literals."	firstChar = '"'		ifTrue: [ ^ MalString withValue: (self stringContents: token) ].	^ MalSymbol withValue: token! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/14/2019 10:03'!readList: aTokenStream	| items current finished |	items := OrderedCollection new.	finished := false.	[ finished ]		whileFalse: [ current := aTokenStream peek.				current = ')'				ifTrue: [ finished := true.					aTokenStream next ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	self assert: current = ')' description: 'Unclosed ('.	^ MalList withValue: items! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/25/2019 01:51'!stringContents: token	| chars isEscape |	"Remove the double quotes and unescape a string literal."	isEscape := false.	chars := OrderedCollection new.	token allButFirst allButLast		do: [ :char | 			isEscape				ifTrue: [ char = $n						ifTrue: [ chars add: Character cr ]						ifFalse: [ chars add: char ].					isEscape := false ]				ifFalse: [ char = $\						ifTrue: [ isEscape := true ]						ifFalse: [ chars add: char ] ] ].	^ '' join: chars! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/14/2019 10:02'!readString: aString	"Lex and parse a string of MAL source code. 	Return a collection of tokens."	| parsed tokens stream |	parsed := OrderedCollection new.	tokens := (MalTokenizer fromString: aString).	stream := tokens readStream.	^ self readForm: stream! !Object subclass: #MalSpecialForm	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSpecialForm commentStamp: 'WilfredHughes 5/19/2019 12:13' prior: 0!I represent special forms in MAL.Special forms choose whether to evaluate their arguments, and cannot be shadowed by variables.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSpecialForm class	instanceVariableNames: ''!!MalSpecialForm class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:25'!call: args withContext: env	self subclassResponsibility ! !!MalSpecialForm class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 00:38'!matchesSymbol: aSymbol	self		subclassesDo: [ :f | 			f malName = aSymbol value				ifTrue: [ ^ f ] ].	^ nil! !!MalSpecialForm class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:30'!malNameself subclassResponsibility ! !MalSpecialForm subclass: #MalDef	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDef commentStamp: 'WilfredHughes 5/19/2019 12:42' prior: 0!I represent the def!! special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDef class	instanceVariableNames: ''!!MalDef class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:48'!call: args withContext: ctx	| sym val |	args size = 2		ifFalse: [ MalWrongArity signal: 'Wrong number of arguments to def!!' ].	sym := args first.	sym class = MalSymbol		ifFalse: [ MalError signal: 'The first argument to def!! must be a symbol' ].	val := args second evalIn: ctx.	ctx env at: sym put: val.	^ val! !!MalDef class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:42'!malName	^ 'def!!'! !MalSpecialForm subclass: #MalDo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDo commentStamp: 'WilfredHughes 5/19/2019 12:40' prior: 0!I represent the do special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDo class	instanceVariableNames: ''!!MalDo class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:40'!malName	^ 'do'! !!MalDo class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:25'!call: args withContext: env		| result |	result := nil.	args allButFirstDo: [ :expr | result := expr evalIn: env ].	^ result! !MalSpecialForm subclass: #MalFn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFn commentStamp: 'WilfredHughes 5/20/2019 09:57' prior: 0!I represent the fn* special form, and create a MalClosure.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFn class	instanceVariableNames: ''!!MalFn class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:52'!call: args withContext: ctx	| bindings body |	args isEmpty		ifTrue: [ MalWrongArity signal: 'fn* requires a list of bindings' ].	bindings := args first.	bindings class = MalList		ifFalse: [ MalError signal: 'fn* requires a list of bindings' ].	(bindings value allSatisfy: [ :e | e class = MalSymbol ])		ifFalse: [ MalError signal: 'fn* bindings must be symbols' ].	body := args allButFirst.	^ MalClosure new		env: ctx env;		bindings: bindings value;		body: body;		yourself! !!MalFn class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 09:57'!malName	^ 'fn*'! !MalSpecialForm subclass: #MalIf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalIf commentStamp: 'WilfredHughes 5/19/2019 12:33' prior: 0!I represent the if special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalIf class	instanceVariableNames: ''!!MalIf class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:33'!malName	^ 'if'! !!MalIf class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:25'!call: args withContext: env	| condition |	args size < 2		ifTrue: [ MalWrongArity signal: 'if requires at least two arguments' ].	condition := args first evalIn: env.	condition isTruthy		ifTrue: [ ^ args second evalIn: env ]		ifFalse: [ ^ args third evalIn: env ]! !MalSpecialForm subclass: #MalLet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLet commentStamp: 'WilfredHughes 5/20/2019 00:33' prior: 0!I represent let* in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLet class	instanceVariableNames: ''!!MalLet class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 12:01'!call: args withContext: ctx	| newEnv bindings result newCtx |	args isEmpty		ifTrue: [ MalWrongArity signal: 'let* requires a list of bindings' ].	newEnv := MalEnv withOuter: ctx env.	newCtx := ctx withEnv: newEnv .	bindings := args first.	bindings class = MalList		ifFalse: [ MalError signal: 'let* requires a list of bindings' ].	(bindings value size isDivisibleBy: 2)		ifFalse: [ MalError signal: 'let* requires an even number of bindings' ].	bindings value		withIndexDo: [ :b :i | 			(i isDivisibleBy: 2)				ifFalse: [ b class = MalSymbol						ifFalse: [ MalError signal: 'Expected a symbol for let binding' ] ] ].	bindings value		pairsDo: [ :var :rawVal | 			| val |			val := rawVal evalIn: newCtx.			newCtx env at: var put: val ].	result := nil.	(args allButFirst) do: [ :expr | result := expr evalIn: newCtx ].	^ result! !!MalLet class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 00:34'!malName	^ 'let*'! !CommandLineHandler subclass: #MalStep	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep commentStamp: 'WilfredHughes 4/29/2019 10:05' prior: 0!I am the base class for all Mal command line handlers. I write a prompt, read input from the user, then dispatch.!!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 5/7/2019 23:35'!activate	| input |	input := self readInputLine.	[ input isEmptyOrNil ]		whileFalse: [ 			self stdout				<< (self rep: input) asString;				lf.			input := self readInputLine ].	self stdout lf.	self exitSuccess! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:08'!readInputLine	self stdout << 'user> '.	^ (Stdio stdin upTo: Character lf asInteger) asString! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:14'!rep: aString	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep class	instanceVariableNames: ''!!MalStep class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:17'!commandName	^ ''! !MalStep subclass: #MalStep0	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep0 commentStamp: 'WilfredHughes 4/29/2019 10:03' prior: 0!I am the simplest Mal REPL, simply echoing my input to the user.!!MalStep0 methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:16'!rep: aString	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep0 class	instanceVariableNames: ''!!MalStep0 class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:15'!commandName	^ 'step0_mal'! !MalStep subclass: #MalStep1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep1 commentStamp: 'WilfredHughes 5/7/2019 23:46' prior: 0!I am a simple Mal REPL, parsing then printing my input.!!MalStep1 methodsFor: 'activation' stamp: 'WilfredHughes 5/14/2019 10:00'!rep: aString	^ [Mal print: (Mal read: aString)] on: MalError do: [ :ex | ex messageText  ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep1 class	instanceVariableNames: ''!!MalStep1 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 01:19'!commandName	^ 'step1_mal'! !MalStep subclass: #MalStep2	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep2 commentStamp: 'WilfredHughes 5/7/2019 23:45' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image wmal 2>/dev/null!!MalStep2 methodsFor: 'activation' stamp: 'WilfredHughes 5/10/2019 10:02'!env: aMalEnv	env := aMalEnv ! !!MalStep2 methodsFor: 'activation' stamp: 'WilfredHughes 5/14/2019 10:00'!rep: aString	^ [ Mal rep: aString in: env ]		on: MalError		do: [ :ex | ex messageText ]! !!MalStep2 methodsFor: 'initialization' stamp: 'WilfredHughes 5/23/2019 10:17'!initialize	self env: Mal defaultEnv! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep2 class	instanceVariableNames: 'env'!!MalStep2 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/7/2019 23:47'!commandName	^ 'step2_mal'! !MalStep subclass: #MalStep3	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep3 commentStamp: 'WilfredHughes 5/14/2019 09:55' prior: 0!I am a CLI interface for executing Mal expressions, supporting binding of variables.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step3_mal 2>/dev/null!!MalStep3 methodsFor: 'activation' stamp: 'WilfredHughes 5/14/2019 09:54'!env: aMalEnv	env := aMalEnv ! !!MalStep3 methodsFor: 'activation' stamp: 'WilfredHughes 5/14/2019 10:00'!rep: aString	^ [ Mal rep: aString in: env ]		on: MalError		do: [ :ex | ex messageText ]! !!MalStep3 methodsFor: 'activation' stamp: 'WilfredHughes 5/23/2019 10:17'!initialize self env: Mal defaultEnv! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep3 class	instanceVariableNames: 'env'!!MalStep3 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/14/2019 09:56'!commandName	^ 'step3_mal'! !MalStep subclass: #MalStep4	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep4 commentStamp: 'WilfredHughes 5/22/2019 10:21' prior: 0!I am a CLI interface for executing Mal expressions, supporting binding of variables.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step4_mal 2>/dev/null!!MalStep4 methodsFor: 'initialization' stamp: 'WilfredHughes 5/23/2019 10:31'!initialize	| out |	super initialize.	out := self stdout.	self assert: out isNotNil description: 'stdout should not be nil'.	self		env:			(Mal defaultEnv				stdout: out;				yourself)! !!MalStep4 methodsFor: 'activation' stamp: 'WilfredHughes 5/22/2019 10:21'!env: aMalEnv	env := aMalEnv ! !!MalStep4 methodsFor: 'activation' stamp: 'WilfredHughes 5/22/2019 10:21'!rep: aString	^ [ Mal rep: aString in: env ]		on: MalError		do: [ :ex | ex messageText ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep4 class	instanceVariableNames: 'env'!!MalStep4 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/22/2019 10:21'!commandName	^ 'step4_mal'! !MalError subclass: #MalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #MalTokenizer	instanceVariableNames: ''	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'MakeALisp'!!MalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalTokenizer class	instanceVariableNames: ''!!MalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/7/2019 22:53'!fromString: aString	"Return a collection of all the tokens in our string."	| pattern matcher result |	"This isn't exactly the same as the MAL docs.   We are forced to treat [ and ] separately due to syntax limitations   in the regex engine, and we ban newlines in comments."	pattern := '[\s,]*(~@|\[|[]{}()''`~^@]|"(\\.|[^\\"])*"|;[^]*|(\[|\]|[^\s{}(''"`,;)])*)'.	matcher := RxMatcher forString: pattern.	result := matcher		matchesOnStream: aString readStream		collect: [ :s | matcher subexpression: 2 ].	^ result reject: [ :str | str isEmpty or: [ str first = $; ] ]! !Object subclass: #MalType	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalType commentStamp: 'WilfredHughes 8/27/2017 18:04' prior: 0!I am the base class for all MAL types.!!MalType methodsFor: 'comparing' stamp: 'WilfredHughes 9/1/2017 19:13'!= anObject	self class = anObject class		ifTrue: [ ^ value = (anObject value) ]		ifFalse: [ ^ false ]! !!MalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 3/13/2018 08:40'!evalIn: env"Default behaviour is types evaluate to themselves."	^ self! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value: anInteger	value := anInteger.	^self! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:16'!isTruthy^ true! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 3/5/2019 09:39'!print	self subclassResponsibility ! !!MalType methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:26'!call: args withContext: ctx	"Try to call this value as a function."	MalNotCallable signal: 'Not a function: ' , self print! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalType class	instanceVariableNames: ''!!MalType class methodsFor: 'initialization' stamp: 'WilfredHughes 9/4/2017 08:30'!withValue: aNumber	| instance |	instance := self new.	instance value: aNumber.	^ instance! !MalType subclass: #MalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!MalBool methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:22'!print	^ self value asString! !!MalBool methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:17'!isTruthy^ self value! !MalType subclass: #MalClosure	instanceVariableNames: 'env bindings body'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalClosure commentStamp: 'WilfredHughes 5/19/2019 10:03' prior: 0!I represent (fn* ...) expressions in MAL.!!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 10:00'!body: anObject	body := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:17'!env: anEnv	env := anEnv! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 10:00'!bindings: anObject	bindings := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:18'!print	^ '#<function>'! !!MalClosure methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:32'!call: rawArgs withContext: callingCtx	| args bodyEnv result bodyCtx |	rawArgs size = bindings size		ifFalse: [ MalWrongArity signal: 'wrong number of arguments to closure' ].	"Evaluate the arguments we've been passed."	args := rawArgs collect: [ :expr | expr evalIn: callingCtx ].	"Create an environment combining the closure env and the bound symbols."	bodyEnv := MalEnv withOuter: env.	bindings withIndexDo: [ :sym :i | bodyEnv at: sym put: (args at: i) ].	bodyCtx := callingCtx withEnv: bodyEnv.	"Evaluate the body and return the value of the last item."	result := nil.	body do: [ :e | result := e evalIn: bodyCtx ].	^ result! !MalType subclass: #MalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFunction commentStamp: 'WilfredHughes 11/5/2017 23:29' prior: 0!I represent callable values in MAL. Currently just built-in functions.!!MalFunction methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:18'!print	^ '#<built-in function>'! !!MalFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:32'!call: args withContext: ctx	self subclassResponsibility! !MalFunction subclass: #MalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAdd commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function + in MAL.!!MalAdd methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:32'!call: args withContext: ctx	"Add args together. TODO: type errors."	| total |	total := 0.	args do: [ :arg | total := total + arg value ].	^ MalInteger withValue: total! !MalFunction subclass: #MalDivide	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDivide commentStamp: 'WilfredHughes 11/6/2017 19:01' prior: 0!The built-in function / in MAL.!!MalDivide methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:33'!call: args withContext: ctx	"Divide args together. TODO: type errors, arity errors"	| result |	result := args first value.	args allButFirstDo: [ :arg | result := result // arg value ].	^ MalInteger withValue: result! !MalFunction subclass: #MalFunctionOneArg	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFunctionOneArg commentStamp: 'WilfredHughes 5/19/2019 09:53' prior: 0!I'm a base class for built-in function that take exactly one argument.!!MalFunctionOneArg methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: envself subclassResponsibility ! !!MalFunctionOneArg methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:34'!call: args withContext: env		args size = 1		ifFalse: [ MalWrongArity signal: 'this function takes one argument' ].	^ self callArg: args first withContext: env! !MalFunctionOneArg subclass: #MalCount	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalCount commentStamp: 'WilfredHughes 5/18/2019 15:47' prior: 0!I represent the count function in MAL.!!MalCount methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: ctx	arg class = MalList		ifFalse: [ MalError signal: 'count requires a list as argument' ].	^ MalInteger withValue: arg size! !MalFunctionOneArg subclass: #MalEmptyPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEmptyPredicate commentStamp: 'WilfredHughes 5/18/2019 15:37' prior: 0!I represent the empty? function in MAL.!!MalEmptyPredicate methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: ctx	arg class = MalList		ifFalse: [ ^ MalBool withValue: false ].	^ MalBool withValue: arg value isEmpty! !MalFunction subclass: #MalGreaterThan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGreaterThan commentStamp: 'WilfredHughes 5/18/2019 15:52' prior: 0!I represent the > function in MAL.!!MalGreaterThan methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:34'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '> requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '> requires numeric arguments' ].	^ MalBool withValue: x value > y value! !MalFunction subclass: #MalGreaterThanOrEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGreaterThanOrEqual commentStamp: 'WilfredHughes 5/18/2019 16:01' prior: 0!I represent the >= function in MAL.!!MalGreaterThanOrEqual methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:34'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '>= requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '>= requires numeric arguments' ].	^ MalBool withValue: x value >= y value! !MalType subclass: #MalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!MalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:17'!print	^ self value asString! !MalType subclass: #MalKeyword	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeyword commentStamp: 'WilfredHughes 3/13/2018 08:30' prior: 0!I represent keywords  in MAL.Keywords are symbols that start with :, e.g. :foo.Keywords evaluate to themselves.!!MalKeyword methodsFor: 'accessing' stamp: 'WilfredHughes 3/13/2018 08:29'!print	^ ':', value! !MalFunction subclass: #MalLessThan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLessThan commentStamp: 'WilfredHughes 5/18/2019 16:00' prior: 0!I represent the < function in MAL.!!MalLessThan methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '< requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '< requires numeric arguments' ].	^ MalBool withValue: x value < y value! !MalFunction subclass: #MalLessThanOrEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLessThanOrEqual commentStamp: 'WilfredHughes 5/18/2019 16:02' prior: 0!I represent the <= function in MAL.!!MalLessThanOrEqual methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '<= requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '<= requires numeric arguments' ].	^ MalBool withValue: x value <= y value! !MalType subclass: #MalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalList commentStamp: 'WilfredHughes 9/26/2017 19:27' prior: 0!I represent a list value in MAL.!!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:36'!evalIn: ctx	| items evalledItems func |	items := self value.	"Empty list evaluates to itself"	items ifEmpty: [ ^ self ].	"Special forms."	(MalSpecialForm matchesSymbol: items first)		ifNotNil: [ :f | ^ f call: items allButFirst withContext: ctx ].	"Evaluate all the items in the list, then call the first arg with the rest."	evalledItems := items collect: [ :item | item evalIn: ctx ].	func := evalledItems first.	^ func call: evalledItems allButFirst withContext: ctx! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:49'!print   | inner |inner := ' ' join: (value collect: #print).^ '(', inner, ')'! !MalFunction subclass: #MalListFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalListFunction commentStamp: 'WilfredHughes 5/18/2019 15:26' prior: 0!I represent the list function in MAL.!!MalListFunction methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	^ MalList withValue: args! !MalFunctionOneArg subclass: #MalListPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalListPredicate commentStamp: 'WilfredHughes 5/18/2019 15:28' prior: 0!I represent the list? function in MAL.!!MalListPredicate methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalList! !MalFunction subclass: #MalMultiply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMultiply commentStamp: 'WilfredHughes 11/6/2017 18:57' prior: 0!The built-in function * in MAL.!!MalMultiply methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	"Multiply args together. TODO: type errors."	| total |	total := 1.	args do: [ :arg | total := total * arg value ].	^ MalInteger withValue: total! !MalType subclass: #MalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:16'!isTruthy^ false! !!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:38'!print	^ 'nil'! !!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 14:44'!printOn: aStream	aStream		nextPutAll: 'a WMalNil'! !MalFunctionOneArg subclass: #MalPrn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrn commentStamp: 'WilfredHughes 5/22/2019 10:23' prior: 0!The built-in prn function in MAL.!!MalPrn methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: ctx	ctx stdout		<< arg print;		lf.	^ MalNil new! !MalType subclass: #MalString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalString commentStamp: 'WilfredHughes 5/5/2019 10:05' prior: 0!I represent string values in MAL.!!MalString methodsFor: 'accessing' stamp: 'WilfredHughes 5/8/2019 00:10'!print   |inner|   	inner := self value copyReplaceAll: '\' with: '\\'.	inner := inner copyReplaceAll: '"' with: '\"'.	^ '"' , inner , '"'! !MalFunction subclass: #MalSubtract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSubtract commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function - in MAL.!!MalSubtract methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	"Subtract args. TODO: type errors."	| total |	args ifEmpty: [ ^ MalInteger withValue: 0 ].	args size = 1		ifTrue: [ ^ MalInteger withValue: args first value negated ].	total := args first value.	args allButFirst do: [ :arg | total := total - arg value ].	^ MalInteger withValue: total! !MalType subclass: #MalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!MalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:41'!evalIn: ctx	ctx env at: self value ifPresent: [ :currentValue | ^currentValue ] ifAbsent: [ MalUnboundSymbol signal: 'Unbound variable: ' , self value ]! !!MalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:54'!print	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSymbol class	instanceVariableNames: ''!!MalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !MalError subclass: #MalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!MalError subclass: #MalWrongArity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalWrongArity commentStamp: 'WilfredHughes 5/18/2019 15:43' prior: 0!Error when calling functions with the wrong number of arguments.!