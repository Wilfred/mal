Object subclass: #Mal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!Mal commentStamp: 'WilfredHughes 6/5/2019 00:51' prior: 0!I am a Make-A-Lisp (MAL) interpreter.You can use me from a CLI (see MalStep) or see:  Mal demo.for an example of running.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mal class	instanceVariableNames: ''!!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/6/2019 00:03'!prelude	^ '(do 	(def!! not (fn* (a) (if a false true)))	(def!! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\n)")))))	)'! !!Mal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/5/2019 09:52'!rep: aString	^ self rep: aString in: MalContext default! !!Mal class methodsFor: 'printing' stamp: 'WilfredHughes 6/4/2019 00:36'!print: aValue	^ aValue asReadableString! !!Mal class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 00:50'!demo	| val |	val := Mal read: '(/ (+ 5 6) 2)'.	^ val evalIn: MalContext default! !!Mal class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 00:50'!eval: aForm in: ctx	^ aForm evalIn: ctx! !!Mal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 5/14/2019 10:01'!read: aString	^ MalReader readString: aString! !Object subclass: #MalContext	instanceVariableNames: 'env stdout'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalContext commentStamp: 'WilfredHughes 6/2/2019 20:39' prior: 0!I represent the state needed to evaluate MAL expressions.To evaluate MAl programs with a full environment use:MalContext default.!!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:40'!withEnv: newEnv"Return a copy of self with a different environment."	^ self class		new		env: newEnv;		stdout: stdout;		yourself! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 6/5/2019 09:49'!globalEnv	| result |	result := env.	[ result outer isNotNil  ] whileTrue: [ result := result outer ].   ^ result! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!stdout: anObject	stdout := anObject! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:39'!env: bindings	env := bindings! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!env	^ env! !!MalContext methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:23'!stdout	^ stdout! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalContext class	instanceVariableNames: ''!!MalContext class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 20:43'!default	"Initialise the MAL context with a full environment."	| ctx |	ctx := self new		env: MalEnv default;		yourself.	(Mal read: (Mal prelude)) evalIn: ctx .	^ ctx! !Object subclass: #MalEnv	instanceVariableNames: 'bindings outer stdout'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEnv commentStamp: 'WilfredHughes 5/22/2019 10:28' prior: 0!I represent environments in MAL. I look up symbols, and can defer toouter environments if a symbol isn't present in my bindings.My API roughly follows Dictionary.I also hold references to Smalltalk objects that MAL needs, such as stdout.!!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:05'!at: aSymbol ifPresent: presentBlock ifAbsent: absentBlock	| key |	key := aSymbol value.	^ bindings		at: key		ifPresent: [ :value | ^ presentBlock cull: value ]		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifPresent: presentBlock ifAbsent: absentBlock ]				ifNil: [ absentBlock value ] ]! !!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:05'!at: aSymbol ifAbsent: aBlock	| key |	key := aSymbol value.	^ bindings		at: key		ifAbsent: [ outer				ifNotNil: [ ^ outer at: key ifAbsent: aBlock ]				ifNil: [ aBlock value ] ]! !!MalEnv methodsFor: 'acccessing' stamp: 'WilfredHughes 5/22/2019 10:12'!at: aSymbol	| key |	self		assert: [ aSymbol class = MalSymbol ]		description: 'env keys should be symbols'.	key := aSymbol value.	^ self		at: key		ifAbsent: [ MalUnboundSymbol signal: 'Unbound variable: ' , key ]! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/22/2019 10:12'!at: aSymbol put: value	"Insert this symbol at this level"	| key |		self		assert: [ aSymbol class = MalSymbol ]		description: 'env keys should be symbols'.	key := aSymbol value.	bindings at: key put: value! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:57'!outer: aLinkedDictionary	outer := aLinkedDictionary! !!MalEnv methodsFor: 'setter' stamp: 'WilfredHughes 5/8/2019 09:56'!bindings: aDictionary	bindings := aDictionary! !!MalEnv methodsFor: 'accessing' stamp: 'WilfredHughes 6/5/2019 09:47'!outer	^ outer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEnv class	instanceVariableNames: ''!!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/8/2019 10:08'!new	^ super new		bindings: Dictionary new;		yourself! !!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/25/2019 11:57'!withOuter: env	self		assert: [ env class = self ]		description: [ 'Outer env class should match this env' ].	^ self new		outer: env;		yourself! !!MalEnv class methodsFor: 'instance creation' stamp: 'WilfredHughes 5/25/2019 13:42'!default	| env |	env := self new.	MalFunction allSubclassesDo: [ :func | env at: (MalSymbol withValue: func malName) put: func new ].	^ env		! !Error subclass: #MalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!Object subclass: #MalLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLiteral commentStamp: 'WilfredHughes 5/25/2019 13:46' prior: 0!I represent atoms in MAL. My subclasses can convert lexemes (a string) to a MAL value.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLiteral class	instanceVariableNames: ''!!MalLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 13:49'!matches: aStringself subclassResponsibility ! !!MalLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 14:09'!fromToken: token	self subclassResponsibility! !MalLiteral subclass: #MalBoolLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalBoolLiteral commentStamp: 'WilfredHughes 5/25/2019 13:47' prior: 0!I convert true and false strings to MAL values.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalBoolLiteral class	instanceVariableNames: ''!!MalBoolLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 13:55'!matches: aString	^ (aString = 'true') | (aString = 'false')! !!MalBoolLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 13:56'!fromToken: aString	aString = 'true' ifTrue: [ ^ MalBool withValue: true ] ifFalse: [ ^MalBool withValue: false ]! !MalLiteral subclass: #MalKeywordLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeywordLiteral commentStamp: 'WilfredHughes 6/2/2019 20:01' prior: 0!I convert strings ':foo' into MalKeyword values.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalKeywordLiteral class	instanceVariableNames: ''!!MalKeywordLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 6/2/2019 20:02'!matches: aString	^ aString first = $:! !!MalKeywordLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 6/2/2019 20:02'!fromToken: aString	^ MalKeyword withValue: aString! !MalLiteral subclass: #MalNilLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNilLiteral commentStamp: 'WilfredHughes 5/29/2019 10:37' prior: 0!I convert the string 'nil' to the MAL nil value.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNilLiteral class	instanceVariableNames: ''!!MalNilLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 10:37'!matches: aString	^ aString = 'nil'! !!MalNilLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 10:38'!fromToken: aString	^ MalNil new! !MalError subclass: #MalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!MalLiteral subclass: #MalNumberLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNumberLiteral commentStamp: 'WilfredHughes 5/25/2019 14:06' prior: 0!I convert number literals to number values in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalNumberLiteral class	instanceVariableNames: ''!!MalNumberLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 14:13'!matches: token	^ token isAllDigits		| (token first = $- & token allButFirst isAllDigits)! !!MalNumberLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/25/2019 14:10'!fromToken: token	^ MalInteger withValue: token asInteger! !Object subclass: #MalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReader commentStamp: 'WilfredHughes 5/29/2019 23:00' prior: 0!I convert MAL source code to an AST instance of MalType.I return an OrderedCollection of forms read.To get started, use #readString:MalReader readString: '(+ 1 2)'.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReader class	instanceVariableNames: ''!!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/31/2019 00:13'!readList: aTokenStream withClose: delimiter	| items current finished |	items := OrderedCollection new.	finished := false.	[ finished ]		whileFalse: [ current := aTokenStream peek.			(self isClose: current expected: delimiter)				ifTrue: [ finished := true.					aTokenStream next ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	(self isClose: current expected: delimiter)		ifFalse: [ MalError signal: 'Unclosed ( [ or {' ].	delimiter = ']'		ifTrue: [ ^ MalVector withValue: items ].	delimiter = '}'		ifTrue: [ ^ MalHashMap withItems: items ].	^ MalList withValue: items! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/6/2019 00:12'!readForm: aTokenStream	| current |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream withClose: ')' ].	current = '['		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream withClose: ']' ].	current = '{'		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream withClose: '}' ].	current = '@'		ifTrue: [ aTokenStream next.			^ MalList withValue: (OrderedCollection with: (MalSymbol withValue: 'deref') with: (self readForm: aTokenStream)) ].	^ self readAtom: aTokenStream! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/31/2019 00:07'!readAtom: aStream	"Parse a single mal type."	| token firstChar |	token := aStream next.	token ifNil: [ MalSyntaxError signal: 'Missing ) ] or }' ].	firstChar := token first: 1.	(self isClose: token)		ifTrue: [ MalSyntaxError signal: 'Unexpected ) ] or }' ].	MalLiteral		allSubclassesDo: [ :atom | 			(atom matches: token)				ifTrue: [ ^ atom fromToken: token ] ].	^ MalSymbol withValue: token! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/31/2019 00:06'!isClose: aString	^ (#(')' ']' '}') includes: aString)! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/31/2019 00:06'!isClose: aString expected: close	(self isClose: aString)		ifFalse: [ ^ false ].	aString = close		ifFalse: [ MalSyntaxError signal: 'wrong closing paren character' ].	^ true! !!MalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/14/2019 10:02'!readString: aString	"Lex and parse a string of MAL source code. 	Return a collection of tokens."	| parsed tokens stream |	parsed := OrderedCollection new.	tokens := (MalTokenizer fromString: aString).	stream := tokens readStream.	^ self readForm: stream! !Object subclass: #MalSpecialForm	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSpecialForm commentStamp: 'WilfredHughes 5/19/2019 12:13' prior: 0!I represent special forms in MAL.Special forms choose whether to evaluate their arguments, and cannot be shadowed by variables.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSpecialForm class	instanceVariableNames: ''!!MalSpecialForm class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:25'!call: args withContext: env	self subclassResponsibility ! !!MalSpecialForm class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 00:38'!matchesSymbol: aSymbol	self		subclassesDo: [ :f | 			f malName = aSymbol value				ifTrue: [ ^ f ] ].	^ nil! !!MalSpecialForm class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:30'!malNameself subclassResponsibility ! !MalSpecialForm subclass: #MalDef	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDef commentStamp: 'WilfredHughes 5/19/2019 12:42' prior: 0!I represent the def!! special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDef class	instanceVariableNames: ''!!MalDef class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 09:49'!call: args withContext: ctx	| sym val |	args size = 2		ifFalse: [ MalWrongArity				signal: ('def!! requires 2 arguments (got {1}' format: {args size}) ].	sym := args first.	sym class = MalSymbol		ifFalse: [ MalError signal: 'The first argument to def!! must be a symbol' ].	val := args second evalIn: ctx.	ctx globalEnv at: sym put: val.	^ val! !!MalDef class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:42'!malName	^ 'def!!'! !MalSpecialForm subclass: #MalDo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDo commentStamp: 'WilfredHughes 5/19/2019 12:40' prior: 0!I represent the do special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDo class	instanceVariableNames: ''!!MalDo class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:40'!malName	^ 'do'! !!MalDo class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 12:25'!call: args withContext: ctx	| result |	result := nil.	args do: [ :expr | result := expr evalIn: ctx ].	^ result! !MalSpecialForm subclass: #MalFn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFn commentStamp: 'WilfredHughes 5/20/2019 09:57' prior: 0!I represent the fn* special form, and create a MalClosure.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFn class	instanceVariableNames: ''!!MalFn class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:02'!call: args withContext: ctx	| wrappedParams params body variadicSym |	args isEmpty		ifTrue: [ MalWrongArity signal: 'fn* requires a list of parameters' ].	wrappedParams := args first.	wrappedParams isIterable		ifFalse: [ MalError signal: 'fn* parameters must be iterable' ].	params := wrappedParams value.	variadicSym := nil.	params		doWithIndex: [ :param :i | 			param class = MalSymbol				ifFalse: [ MalError signal: 'fn* parameters must be symbols' ].			param value = '&'				ifTrue: [ i = (params size - 1)						ifFalse: [ MalError signal: '& must be in the penultimate position' ].					variadicSym := params last ] ].	variadicSym isNotNil		ifTrue: [ params := params allButLast: 2 ].	body := args allButFirst.	^ MalClosure new		env: ctx env;		bindings: params;		variadicSym: variadicSym;		body: body;		yourself! !!MalFn class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 09:57'!malName	^ 'fn*'! !MalSpecialForm subclass: #MalIf	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalIf commentStamp: 'WilfredHughes 5/19/2019 12:33' prior: 0!I represent the if special form in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalIf class	instanceVariableNames: ''!!MalIf class methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:33'!malName	^ 'if'! !!MalIf class methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 13:30'!call: args withContext: ctx	| condition result |	args size < 2		ifTrue: [ MalWrongArity signal: 'if requires at least two arguments' ].	condition := args first evalIn: ctx.	condition isTruthy		ifTrue: [ ^ args second evalIn: ctx ].	result := MalNil new.	(args allButFirst: 2) do: [ :arg | result := arg evalIn: ctx ].	^ result! !MalSpecialForm subclass: #MalLet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLet commentStamp: 'WilfredHughes 5/20/2019 00:33' prior: 0!I represent let* in MAL.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLet class	instanceVariableNames: ''!!MalLet class methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 20:31'!call: args withContext: ctx	| newEnv bindings result newCtx |	args isEmpty		ifTrue: [ MalWrongArity signal: 'let* requires a list of bindings' ].	newEnv := MalEnv withOuter: ctx env.	newCtx := ctx withEnv: newEnv.	bindings := args first.	({ MalList. MalVector } includes: (bindings class))		ifFalse: [ MalError signal: 'let* requires a list of bindings' ].	(bindings value size isDivisibleBy: 2)		ifFalse: [ MalError signal: 'let* requires an even number of bindings' ].	bindings value		withIndexDo: [ :b :i | 			(i isDivisibleBy: 2)				ifFalse: [ b class = MalSymbol						ifFalse: [ MalError signal: 'Expected a symbol for let binding' ] ] ].	bindings value		pairsDo: [ :var :rawVal | 			| val |			val := rawVal evalIn: newCtx.			newCtx env at: var put: val ].	result := nil.	args allButFirst do: [ :expr | result := expr evalIn: newCtx ].	^ result! !!MalLet class methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 00:34'!malName	^ 'let*'! !CommandLineHandler subclass: #MalStep	instanceVariableNames: 'ctx'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep commentStamp: 'WilfredHughes 4/29/2019 10:05' prior: 0!I am the base class for all Mal command line handlers. I write a prompt, read input from the user, then dispatch.!!MalStep methodsFor: 'initialization' stamp: 'WilfredHughes 6/2/2019 20:44'!initialize	super initialize.	ctx := MalContext default		stdout: self stdout;		yourself! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 5/7/2019 23:35'!activate	| input |	input := self readInputLine.	[ input isEmptyOrNil ]		whileFalse: [ 			self stdout				<< (self rep: input) asString;				lf.			input := self readInputLine ].	self stdout lf.	self exitSuccess! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:08'!readInputLine	self stdout << 'user> '.	^ (Stdio stdin upTo: Character lf asInteger) asString! !!MalStep methodsFor: 'activation' stamp: 'WilfredHughes 5/25/2019 12:15'!rep: aString	^ [ Mal rep: aString in: ctx ]		on: MalError		do: [ :ex | ex messageText ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep class	instanceVariableNames: ''!!MalStep class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:17'!commandName	^ ''! !MalStep subclass: #MalStep0	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep0 commentStamp: 'WilfredHughes 4/29/2019 10:03' prior: 0!I am the simplest Mal REPL, simply echoing my input to the user.!!MalStep0 methodsFor: 'activation' stamp: 'WilfredHughes 4/29/2019 10:16'!rep: aString	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep0 class	instanceVariableNames: ''!!MalStep0 class methodsFor: 'accessing' stamp: 'WilfredHughes 4/29/2019 10:15'!commandName	^ 'step0_mal'! !MalStep subclass: #MalStep1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep1 commentStamp: 'WilfredHughes 5/7/2019 23:46' prior: 0!I am a simple Mal REPL, parsing then printing my input.!!MalStep1 methodsFor: 'activation' stamp: 'WilfredHughes 5/14/2019 10:00'!rep: aString	^ [Mal print: (Mal read: aString)] on: MalError do: [ :ex | ex messageText  ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep1 class	instanceVariableNames: ''!!MalStep1 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 01:19'!commandName	^ 'step1_mal'! !MalStep subclass: #MalStep2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep2 commentStamp: 'WilfredHughes 5/7/2019 23:45' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image wmal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep2 class	instanceVariableNames: 'env'!!MalStep2 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/7/2019 23:47'!commandName	^ 'step2_mal'! !MalStep subclass: #MalStep3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep3 commentStamp: 'WilfredHughes 5/14/2019 09:55' prior: 0!I am a CLI interface for executing Mal expressions, supporting binding of variables.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step3_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep3 class	instanceVariableNames: 'env'!!MalStep3 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/14/2019 09:56'!commandName	^ 'step3_mal'! !MalStep subclass: #MalStep4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep4 commentStamp: 'WilfredHughes 5/22/2019 10:21' prior: 0!I am a CLI interface for executing Mal expressions, supporting binding of variables.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step4_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep4 class	instanceVariableNames: 'env'!!MalStep4 class methodsFor: 'accessing' stamp: 'WilfredHughes 5/22/2019 10:21'!commandName	^ 'step4_mal'! !MalStep subclass: #MalStep5	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep5 commentStamp: 'WilfredHughes 6/2/2019 20:56' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step5_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep5 class	instanceVariableNames: 'env'!!MalStep5 class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 20:57'!commandName	^ 'step5_mal'! !MalStep subclass: #MalStep6	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStep6 commentStamp: 'WilfredHughes 6/5/2019 00:47' prior: 0!I am a CLI interface for executing Mal expressions.You can use me as follows:    $ echo '(+ 1 2)' | ~/Pharo/vms/70-x64/pharo -headless ~/Pharo/images/WMal/WMal.image step6_mal 2>/dev/null!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStep6 class	instanceVariableNames: 'env'!!MalStep6 class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 23:57'!commandName	^ 'step6_mal'! !MalLiteral subclass: #MalStringLiteral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStringLiteral commentStamp: 'WilfredHughes 5/29/2019 22:53' prior: 0!I convert strings '"foo"' into MAL strings.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStringLiteral class	instanceVariableNames: ''!!MalStringLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 22:55'!stringContents: token	| chars isEscape |	"Remove the double quotes and unescape a string literal."	isEscape := false.	chars := OrderedCollection new.	token allButFirst allButLast		do: [ :char | 			isEscape				ifTrue: [ char = $n						ifTrue: [ chars add: Character cr ]						ifFalse: [ chars add: char ].					isEscape := false ]				ifFalse: [ char = $\						ifTrue: [ isEscape := true ]						ifFalse: [ chars add: char ] ] ].	^ '' join: chars! !!MalStringLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 22:54'!matches: aString	^ aString first = $"! !!MalStringLiteral class methodsFor: 'testing' stamp: 'WilfredHughes 5/29/2019 22:57'!fromToken: token"TODO: Check for a closing double-quote on string literals."	^ MalString withValue: (self stringContents: token)! !MalError subclass: #MalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #MalTokenizer	instanceVariableNames: ''	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'MakeALisp'!!MalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalTokenizer class	instanceVariableNames: ''!!MalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 6/5/2019 23:58'!fromString: aString	"Return a collection of all the tokens in our string."	| pattern matcher result |	"This isn't exactly the same as the MAL docs.   We are forced to treat [ and ] separately due to syntax limitations   in the regex engine (a range cannot contain [, see 	https://stackoverflow.com/questions/45824000/) and 	we ban carriage return/line feeds in comments."	pattern := '[\s,]*(~@|\[|\]|[{}()''`~^@]|"(\\.|[^\\"])*"|;[^', Character cr asString , Character lf asString , ']*|([^]\s{}(''"`,;)])*)'.	matcher := RxMatcher forString: pattern.	result := matcher		matchesOnStream: aString readStream		collect: [ :s | matcher subexpression: 2 ].	^ result reject: [ :str | str isEmpty or: [ str first = $; ] ]! !Object subclass: #MalType	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalType commentStamp: 'WilfredHughes 5/30/2019 09:59' prior: 0!I am the base class for all MAL types. Every type wraps an instance variable 'value', and knows how to print and evaluate.!!MalType methodsFor: 'comparing' stamp: 'WilfredHughes 5/30/2019 23:20'!hash ^ self value hash! !!MalType methodsFor: 'comparing' stamp: 'WilfredHughes 6/3/2019 22:05'!= anObject   (self isIterable & anObject isIterable) ifTrue: [^ value = anObject value].   self class = anObject class ifFalse: [ ^ false ].   ^ value = anObject value! !!MalType methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 00:36'!call: args withContext: ctx	"Try to call this value as a function."	MalNotCallable signal: 'Not a function: ' , self asReadableString! !!MalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !!MalType methodsFor: 'converting' stamp: 'WilfredHughes 6/4/2019 00:36'!asString ^ self asReadableString! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:29'!evalIn: env	"Default behaviour is that types evaluate to themselves."	^ self! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 19:35'!isCallable	^ false! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:00'!isIterable	^ false! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value: anInteger	value := anInteger.	^self! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	self subclassResponsibility ! !!MalType methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:16'!isTruthy^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalType class	instanceVariableNames: ''!!MalType class methodsFor: 'initialization' stamp: 'WilfredHughes 5/30/2019 10:00'!withValue: aDictionary	| instance |	instance := self new.	instance value: aDictionary.	^ instance! !MalType subclass: #MalAtom	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAtom commentStamp: 'WilfredHughes 6/3/2019 22:14' prior: 0!I represent atom values in MAL.!!MalAtom methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ '(atom ', self value asReadableString , ')'! !MalType subclass: #MalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!MalBool methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ self value asString! !!MalBool methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:17'!isTruthy^ self value! !MalType subclass: #MalClosure	instanceVariableNames: 'env bindings variadicSym body'	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalClosure commentStamp: 'WilfredHughes 5/19/2019 10:03' prior: 0!I represent (fn* ...) expressions in MAL.!!MalClosure methodsFor: 'evaluating' stamp: 'WilfredHughes 5/29/2019 10:18'!call: rawArgs withContext: callingCtx	| args bodyEnv result bodyCtx |	rawArgs size < bindings size		ifTrue: [ MalWrongArity signal: 'not enough arguments to closure' ].	rawArgs size > bindings size & variadicSym isNil		ifTrue: [ MalWrongArity signal: 'too many arguments to closure' ].	"Evaluate the arguments we've been passed."	args := rawArgs collect: [ :expr | expr evalIn: callingCtx ].	"Create an environment combining the closure env and the bound symbols."	bodyEnv := MalEnv withOuter: env.	bindings withIndexDo: [ :sym :i | bodyEnv at: sym put: (args at: i) ].	variadicSym isNotNil ifTrue: [ bodyEnv at: variadicSym put: (MalList withValue: (args allButFirst: (bindings size)))].		bodyCtx := callingCtx withEnv: bodyEnv.	"Evaluate the body and return the value of the last item."	result := nil.	body do: [ :e | result := e evalIn: bodyCtx ].	^ result! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 10:00'!body: anObject	body := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:27'!bindings	^ bindings! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 19:36'!isCallable ^ true! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ '#<function>'! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:25'!variadicSym	^ variadicSym! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/19/2019 12:17'!env: anEnv	env := anEnv! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/20/2019 10:00'!bindings: anObject	bindings := anObject! !!MalClosure methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:25'!variadicSym: anObject	variadicSym := anObject! !MalType subclass: #MalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFunction commentStamp: 'WilfredHughes 5/25/2019 13:37' prior: 0!I represent built-in functions in MAL.If a child implements the malName method, it will be included in the default environment.!!MalFunction methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ '#<built-in function>'! !!MalFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 19:44'!ensure: args haveArity: arity	| msg |	msg := 'The function {1} takes {2} argument{3} (got {4})'		format:			{self class malName.			arity.			(arity = 1				ifTrue: [ '' ]				ifFalse: [ 's' ]). args size}.	args size = arity		ifFalse: [ MalWrongArity signal: msg ]! !!MalFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 19:36'!isCallable ^ true! !!MalFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:32'!call: args withContext: ctx	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalFunction class	instanceVariableNames: ''!!MalFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:37'!malName^ nil! !MalFunction subclass: #MalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAdd commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function + in MAL.!!MalAdd methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:32'!call: args withContext: ctx	"Add args together. TODO: type errors."	| total |	total := 0.	args do: [ :arg | total := total + arg value ].	^ MalInteger withValue: total! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAdd class	instanceVariableNames: ''!!MalAdd class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:37'!malName ^ '+'! !MalFunction subclass: #MalDivide	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDivide commentStamp: 'WilfredHughes 11/6/2017 19:01' prior: 0!The built-in function / in MAL.!!MalDivide methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:33'!call: args withContext: ctx	"Divide args together. TODO: type errors, arity errors"	| result |	result := args first value.	args allButFirstDo: [ :arg | result := result // arg value ].	^ MalInteger withValue: result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDivide class	instanceVariableNames: ''!!MalDivide class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ '/'! !MalFunction subclass: #MalEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEqual commentStamp: 'WilfredHughes 5/25/2019 12:31' prior: 0!I represent the = function in MAL.!!MalEqual methodsFor: 'evaluating' stamp: 'WilfredHughes 6/5/2019 01:03'!call: args withContext: ctx	self ensure: args haveArity: 2.	^ MalBool withValue: args first = args second! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEqual class	instanceVariableNames: ''!!MalEqual class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ '='! !MalFunction subclass: #MalFunctionOneArg	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalFunctionOneArg commentStamp: 'WilfredHughes 5/19/2019 09:53' prior: 0!I'm a base class for built-in function that take exactly one argument.!!MalFunctionOneArg methodsFor: 'evaluating' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: envself subclassResponsibility ! !!MalFunctionOneArg methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 19:31'!call: args withContext: env	self ensure: args haveArity: 1.	^ self callArg: args first withContext: env! !MalFunctionOneArg subclass: #MalAtomFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAtomFunction commentStamp: 'WilfredHughes 6/3/2019 22:16' prior: 0!I represent the function that creates atom values in MAL.!!MalAtomFunction methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:17'!callArg: arg withContext: ctx	^ MalAtom withValue: arg! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAtomFunction class	instanceVariableNames: ''!!MalAtomFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:17'!malName	^ 'atom'! !MalFunctionOneArg subclass: #MalAtomPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalAtomPredicate commentStamp: 'WilfredHughes 6/3/2019 22:17' prior: 0!I represent the atom? function in MAL.!!MalAtomPredicate methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:18'!callArg: arg withContext: ctx	^ MalBool withValue: (arg class = MalAtom)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalAtomPredicate class	instanceVariableNames: ''!!MalAtomPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:17'!malName	^ 'atom?'! !MalFunctionOneArg subclass: #MalCount	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalCount commentStamp: 'WilfredHughes 5/18/2019 15:47' prior: 0!I represent the count function in MAL.!!MalCount methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:03'!callArg: arg withContext: ctx	"MAL requires nil to return 0, so return 0 for any non-list."	arg isIterable		ifFalse: [ ^ MalInteger withValue: 0 ].	^ MalInteger withValue: arg size! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalCount class	instanceVariableNames: ''!!MalCount class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'count'! !MalFunctionOneArg subclass: #MalDeref	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalDeref commentStamp: 'WilfredHughes 6/3/2019 22:19' prior: 0!I represent the deref function in MAL.!!MalDeref methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 22:20'!callArg: arg withContext: env	arg class = MalAtom ifFalse: [ MalError signal: 'deref requires an atom' ].	^ arg value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalDeref class	instanceVariableNames: ''!!MalDeref class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:20'!malName	^ 'deref'! !MalFunctionOneArg subclass: #MalEmptyPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEmptyPredicate commentStamp: 'WilfredHughes 5/18/2019 15:37' prior: 0!I represent the empty? function in MAL.!!MalEmptyPredicate methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 6/3/2019 22:03'!callArg: arg withContext: ctx	arg isIterable		ifFalse: [ ^ MalBool withValue: false ].	^ MalBool withValue: arg value isEmpty! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEmptyPredicate class	instanceVariableNames: ''!!MalEmptyPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'empty?'! !MalFunctionOneArg subclass: #MalEval	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalEval commentStamp: 'WilfredHughes 6/2/2019 23:53' prior: 0!I represent the eval built-in function in MAL.I do not handle evaluation (see the evalIn: message), but I expose evaluation to the user.!!MalEval methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 23:53'!callArg: arg withContext: ctx	^ arg evalIn: ctx! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalEval class	instanceVariableNames: ''!!MalEval class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 00:00'!malName	^ 'eval'! !MalFunction subclass: #MalGreaterThan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGreaterThan commentStamp: 'WilfredHughes 5/18/2019 15:52' prior: 0!I represent the > function in MAL.!!MalGreaterThan methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:34'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '> requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '> requires numeric arguments' ].	^ MalBool withValue: x value > y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalGreaterThan class	instanceVariableNames: ''!!MalGreaterThan class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '>'! !MalFunction subclass: #MalGreaterThanOrEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalGreaterThanOrEqual commentStamp: 'WilfredHughes 5/18/2019 16:01' prior: 0!I represent the >= function in MAL.!!MalGreaterThanOrEqual methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:34'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '>= requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '>= requires numeric arguments' ].	^ MalBool withValue: x value >= y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalGreaterThanOrEqual class	instanceVariableNames: ''!!MalGreaterThanOrEqual class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '>='! !MalType subclass: #MalHashMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalHashMap commentStamp: 'WilfredHughes 5/30/2019 09:54' prior: 0!I represent hash maps {:foo "bar"} in MAL.!!MalHashMap methodsFor: 'accessing' stamp: 'WilfredHughes 5/31/2019 10:27'!evalIn: ctx	| evalledItems |	evalledItems := self value		associations collect: [ :assoc | ((assoc key) evalIn: ctx) -> ((assoc value) evalIn: ctx) ].	^ MalHashMap withValue: (Dictionary newFrom: evalledItems)! !!MalHashMap methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	| printedItems |	printedItems := OrderedCollection new.	value		associationsDo: [ :assoc | 			printedItems add: assoc key asReadableString.			printedItems add: assoc value asReadableString ].	^ '{' , (' ' join: printedItems) , '}'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalHashMap class	instanceVariableNames: ''!!MalHashMap class methodsFor: 'initialization' stamp: 'WilfredHughes 5/31/2019 00:13'!withItems: items	| value |	value := Dictionary new.	items pairsDo: [ :k :v | value at: k put: v ].	^ self withValue: value! !MalType subclass: #MalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!MalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ self value asString! !MalType subclass: #MalKeyword	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalKeyword commentStamp: 'WilfredHughes 3/13/2018 08:30' prior: 0!I represent keywords  in MAL.Keywords are symbols that start with :, e.g. :foo.Keywords evaluate to themselves.!!MalKeyword methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ value! !MalFunction subclass: #MalLessThan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLessThan commentStamp: 'WilfredHughes 5/18/2019 16:00' prior: 0!I represent the < function in MAL.!!MalLessThan methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '< requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '< requires numeric arguments' ].	^ MalBool withValue: x value < y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLessThan class	instanceVariableNames: ''!!MalLessThan class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '<'! !MalFunction subclass: #MalLessThanOrEqual	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalLessThanOrEqual commentStamp: 'WilfredHughes 5/18/2019 16:02' prior: 0!I represent the <= function in MAL.!!MalLessThanOrEqual methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	| x y |	args size < 2		ifTrue: [ MalWrongArity signal: '<= requires two arguments' ].	x := args first.	y := args second.	(x class = MalInteger and: [ y class = MalInteger ])		ifFalse: [ MalError signal: '<= requires numeric arguments' ].	^ MalBool withValue: x value <= y value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalLessThanOrEqual class	instanceVariableNames: ''!!MalLessThanOrEqual class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '<='! !MalType subclass: #MalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalList commentStamp: 'WilfredHughes 9/26/2017 19:27' prior: 0!I represent a list value in MAL.!!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:36'!evalIn: ctx	| items evalledItems func |	items := self value.	"Empty list evaluates to itself"	items ifEmpty: [ ^ self ].	"Special forms."	(MalSpecialForm matchesSymbol: items first)		ifNotNil: [ :f | ^ f call: items allButFirst withContext: ctx ].	"Evaluate all the items in the list, then call the first arg with the rest."	evalledItems := items collect: [ :item | item evalIn: ctx ].	func := evalledItems first.	^ func call: evalledItems allButFirst withContext: ctx! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:00'!isIterable ^ true! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString   | inner |inner := ' ' join: (value collect: #asReadableString).^ '(', inner, ')'! !!MalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!MalList methodsFor: 'converting' stamp: 'WilfredHughes 6/3/2019 22:10'!asString	| inner |	inner := ' ' join: (value collect: #asString).	^ '(' , inner , ')'! !MalFunction subclass: #MalListFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalListFunction commentStamp: 'WilfredHughes 5/18/2019 15:26' prior: 0!I represent the list function in MAL.!!MalListFunction methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	^ MalList withValue: args! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalListFunction class	instanceVariableNames: ''!!MalListFunction class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ 'list'! !MalFunctionOneArg subclass: #MalListPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalListPredicate commentStamp: 'WilfredHughes 5/18/2019 15:28' prior: 0!I represent the list? function in MAL.!!MalListPredicate methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 5/25/2019 11:34'!callArg: arg withContext: ctx	^ MalBool withValue: arg class = MalList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalListPredicate class	instanceVariableNames: ''!!MalListPredicate class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'list?'! !MalFunction subclass: #MalMultiply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalMultiply commentStamp: 'WilfredHughes 11/6/2017 18:57' prior: 0!The built-in function * in MAL.!!MalMultiply methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	"Multiply args together. TODO: type errors."	| total |	total := 1.	args do: [ :arg | total := total * arg value ].	^ MalInteger withValue: total! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalMultiply class	instanceVariableNames: ''!!MalMultiply class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:39'!malName^ '*'! !MalType subclass: #MalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ 'nil'! !!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/6/2019 14:44'!printOn: aStream	aStream		nextPutAll: 'a WMalNil'! !!MalNil methodsFor: 'accessing' stamp: 'WilfredHughes 5/18/2019 00:16'!isTruthy^ false! !MalFunction subclass: #MalPrStr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrStr commentStamp: 'WilfredHughes 6/3/2019 09:25' prior: 0!I repressent the pr-str function in MAL.!!MalPrStr methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 00:36'!call: args withContext: ctx	| printedArgs |	printedArgs := args collect: [ :arg | arg asReadableString ].	^ MalString withValue: (' ' join: printedArgs)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalPrStr class	instanceVariableNames: ''!!MalPrStr class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 09:27'!malName	^ 'pr-str'! !MalFunction subclass: #MalPrintln	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrintln commentStamp: 'WilfredHughes 6/3/2019 21:50' prior: 0!I represent the println function in MAL.!!MalPrintln methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 21:57'!call: args withContext: ctx	ctx stdout		<< (' ' join: (args collect: #asString));		lf.	^ MalNil new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalPrintln class	instanceVariableNames: ''!!MalPrintln class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:12'!malName	^ 'println'! !MalFunction subclass: #MalPrn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalPrn commentStamp: 'WilfredHughes 5/22/2019 10:23' prior: 0!The built-in prn function in MAL.!!MalPrn methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 00:36'!call: args withContext: ctx  | printedArgs |printedArgs := args collect: [ :arg | arg asReadableString ].		ctx stdout		<< (' ' join: printedArgs);		lf.	^ MalNil new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalPrn class	instanceVariableNames: ''!!MalPrn class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:38'!malName^ 'prn'! !MalFunctionOneArg subclass: #MalReadString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReadString commentStamp: 'WilfredHughes 6/2/2019 23:42' prior: 0!I represent the read-string built-in function in MAL.!!MalReadString methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 23:49'!callArg: arg withContext: ctx	arg class = MalString		ifFalse: [ ^ MalError signal: 'Expected a string' ].	^ Mal read: arg value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReadString class	instanceVariableNames: ''!!MalReadString class methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 23:46'!malName	^ 'read-string'! !MalFunction subclass: #MalReset	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalReset commentStamp: 'WilfredHughes 6/4/2019 00:39' prior: 0!I represent the reset!! function in MAL.!!MalReset methodsFor: 'evaluating' stamp: 'WilfredHughes 6/4/2019 19:32'!call: args withContext: ctx	| atom |	self ensure: args haveArity: 2.	atom := args first.	atom class = MalAtom		ifFalse: [ MalError signal: 'first argument to reset!! must be an atom' ].	atom value: args second.	^ args second! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalReset class	instanceVariableNames: ''!!MalReset class methodsFor: 'accessing' stamp: 'WilfredHughes 6/5/2019 00:44'!malName	^ 'reset!!'! !MalFunctionOneArg subclass: #MalSlurp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSlurp commentStamp: 'WilfredHughes 6/2/2019 23:49' prior: 0!I represent the slurp built-in function in MAL.!!MalSlurp methodsFor: 'evaluating' stamp: 'WilfredHughes 6/2/2019 23:50'!callArg: arg withContext: ctx	arg class = MalString		ifFalse: [ ^ MalError signal: 'Expected a string' ].	^ MalString withValue: (arg value asFileReference readStream upToEnd)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSlurp class	instanceVariableNames: ''!!MalSlurp class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 00:00'!malName	^ 'slurp'! !MalFunction subclass: #MalStr	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalStr commentStamp: 'WilfredHughes 6/3/2019 20:53' prior: 0!I represent the str built-in function in MAL.!!MalStr methodsFor: 'evaluating' stamp: 'WilfredHughes 6/3/2019 21:56'!call: args withContext: ctx	| stringArgs |	stringArgs := args collect: #asString.	^ MalString withValue: ('' join: stringArgs)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalStr class	instanceVariableNames: ''!!MalStr class methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 20:56'!malName	^ 'str'! !MalType subclass: #MalString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalString commentStamp: 'WilfredHughes 5/5/2019 10:05' prior: 0!I represent string values in MAL.!!MalString methodsFor: 'converting' stamp: 'WilfredHughes 6/3/2019 21:54'!asString ^ value! !!MalString methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	| inner |	inner := self value copyReplaceAll: '\' with: '\\'.	inner := inner copyReplaceAll: '' with: '\n'.	inner := inner copyReplaceAll: '"' with: '\"'.	^ '"' , inner , '"'! !MalFunction subclass: #MalSubtract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSubtract commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function - in MAL.!!MalSubtract methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 11:35'!call: args withContext: ctx	"Subtract args. TODO: type errors."	| total |	args ifEmpty: [ ^ MalInteger withValue: 0 ].	args size = 1		ifTrue: [ ^ MalInteger withValue: args first value negated ].	total := args first value.	args allButFirst do: [ :arg | total := total - arg value ].	^ MalInteger withValue: total! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSubtract class	instanceVariableNames: ''!!MalSubtract class methodsFor: 'accessing' stamp: 'WilfredHughes 5/25/2019 13:40'!malName^ '-'! !MalFunction subclass: #MalSwap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSwap commentStamp: 'WilfredHughes 6/4/2019 19:33' prior: 0!I represent the swap!! function in MAL.!!MalSwap methodsFor: 'evaluating' stamp: 'WilfredHughes 6/6/2019 00:05'!call: args withContext: ctx	| atom func funcArgs newValue |	args size < 2		ifTrue: [ MalWrongArity signal: 'swap!! requires at least 2 arguments' ].	atom := args first.	atom class = MalAtom		ifFalse: [ MalError signal: 'first argument to swap!! must be an atom' ].	func := args second.	func isCallable		ifFalse: [ MalError signal: 'second argument to swap!! must be a function' ].	funcArgs := OrderedCollection with: atom value.	funcArgs addAll: (args allButFirst: 2).	newValue := func call: funcArgs withContext: ctx.	atom value: newValue.	^ newValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSwap class	instanceVariableNames: ''!!MalSwap class methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 19:42'!malName	^ 'swap!!'! !MalType subclass: #MalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!MalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 6/2/2019 21:09'!evalIn: ctx	ctx env		at: self value		ifPresent: [ :currentValue | ^ currentValue ]		ifAbsent: [ MalUnboundSymbol signal: 'Variable ''' , self value , ''' not found' ]! !!MalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MalSymbol class	instanceVariableNames: ''!!MalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !MalError subclass: #MalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!MalType subclass: #MalVector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalVector commentStamp: 'WilfredHughes 5/29/2019 10:30' prior: 0!I represent vectors [ 1 2 3 ] in MAL.!!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 5/30/2019 09:56'!evalIn: ctx	"A vector evaluates all its elements."	^ MalVector		withValue: (self value collect: [ :item | item evalIn: ctx ])! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:00'!isIterable^ true! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/4/2019 00:36'!asReadableString	| inner |	inner := ' ' join: (value collect: #asReadableString).	^ '[' , inner , ']'! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 6/3/2019 22:10'!asString	| inner |	inner := ' ' join: (value collect: #asString).	^ '[' , inner , ']'! !!MalVector methodsFor: 'accessing' stamp: 'WilfredHughes 5/29/2019 10:30'!size	^ value size! !MalError subclass: #MalWrongArity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MakeALisp'!!MalWrongArity commentStamp: 'WilfredHughes 5/18/2019 15:43' prior: 0!Error when calling functions with the wrong number of arguments.!