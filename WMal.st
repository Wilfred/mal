Object subclass: #WMal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMal commentStamp: 'WilfredHughes 8/22/2017 00:27' prior: 0!I am a Make-A-Lisp (MAL) interpreter.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMal class	instanceVariableNames: ''!!WMal class methodsFor: 'printing' stamp: 'WilfredHughes 11/5/2017 22:44'!print: aValue	^ aValue print! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:52'!rep: aString^ self rep: aString in: (self defaultEnv )! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:56'!eval: aForm in: env	^ aForm evalIn: env! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/6/2017 00:01'!defaultEnv	^ Dictionary new		at: '+' put: WMalAdd new;		at: '-' put: WMalSubtract  new;		yourself! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!WMal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 11/5/2017 22:45'!read: aString	^ WMalReader readString: aString! !Error subclass: #WMalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!WMalError subclass: #WMalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!Object subclass: #WMalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalReader commentStamp: 'WilfredHughes 11/3/2017 08:02' prior: 0!I convert MAL source code to an AST instance of WMalType.To get started, use #readString:WMalReader readString: '(+ 1 2').!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalReader class	instanceVariableNames: ''!!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/3/2017 09:01'!readAtom: aStream	"Parse a single mal type."	| token |	token := aStream next.	token ifNil: [ WMalSyntaxError signal: 'Missing )' ].	token = ')'		ifTrue: [ WMalSyntaxError signal: 'Unexpected )' ].	token isAllDigits		ifTrue: [ ^ WMalInteger withValue: token asInteger ].	token = 'nil'		ifTrue: [ ^ WMalNil new ].	token = 'true'		ifTrue: [ ^ WMalBool withValue: true ].	token = 'false'		ifTrue: [ ^ WMalBool withValue: false ].	^ WMalSymbol withValue: token! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:36'!readForm: aTokenStream	| current |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream ]		ifFalse: [ ^ self readAtom: aTokenStream ]! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:41'!readString: aString	"Lex and parse a string of MAL source code."	| parsed tokens |	parsed := OrderedCollection new.	tokens := (WMalTokenizer withSource: aString) tokenize.	^self readForm: tokens readStream! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 10/30/2017 08:32'!readList: aTokenStream	| items current finished |	items := OrderedCollection new.	finished := false.	[ finished ]		whileFalse: [ current := aTokenStream peek.			Transcript				show: current;				cr.			current = ')'				ifTrue: [ finished := true. aTokenStream next. ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	self assert: current = ')' description: 'Unclosed ('.	^ WMalList withValue: items! !WMalError subclass: #WMalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #WMalTokenizer	instanceVariableNames: 'source'	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'WMal'!!WMalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!!WMalTokenizer methodsFor: 'accessing' stamp: 'WilfredHughes 8/22/2017 19:35'!source: aString	source := aString! !!WMalTokenizer methodsFor: 'instance creation' stamp: 'WilfredHughes 10/30/2017 08:20'!tokenize	"Return a collection of all the tokens in our string."	| matcher result |	matcher := RxMatcher forString: TokenPattern.	result := OrderedCollection new.	matcher		matchesOnStream: source readStream		do: [ :s :m | result add: (m subexpression: 2) ].	^ result reject: [ :str | str isEmpty ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalTokenizer class	instanceVariableNames: 'source'!!WMalTokenizer class methodsFor: 'initialization' stamp: 'WilfredHughes 8/22/2017 19:18'!initialize	"This isn't exactly the same as the MAL docs.We are forced to treat [ and ] separately due to syntax limitationsin the regex engine."	TokenPattern := '[\s,]*(~@|\[|[]{}()''`~^@]|"(\\.|[^\\"])*"|;.*|(\[|\]|[^\s{}(''"`,;)])*)'! !!WMalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 8/25/2017 08:31'!withSource: aString	"Initialise with source code specified."	| instance |	instance := self new.	instance source: aString.	^ instance! !Object subclass: #WMalType	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalType commentStamp: 'WilfredHughes 8/27/2017 18:04' prior: 0!I am the base class for all MAL types.!!WMalType methodsFor: 'comparing' stamp: 'WilfredHughes 9/1/2017 19:13'!= anObject	self class = anObject class		ifTrue: [ ^ value = (anObject value) ]		ifFalse: [ ^ false ]! !!WMalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value: anInteger	value := anInteger.	^self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:13'!evalIn: env 	^ self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:33'!call: args"Try to call this value as a function."	WMalNotCallable signal: 'Not a function: ' , self print! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:14'!print	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalType class	instanceVariableNames: ''!!WMalType class methodsFor: 'initialization' stamp: 'WilfredHughes 9/4/2017 08:30'!withValue: aNumber	| instance |	instance := self new.	instance value: aNumber.	^ instance! !WMalType subclass: #WMalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!WMalBool methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:22'!print	^ self value asString! !WMalType subclass: #WMalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalFunction commentStamp: 'WilfredHughes 11/5/2017 23:29' prior: 0!I represent callable values in MAL. Currently just built-in functions.!!WMalFunction methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:33'!call: args	self subclassResponsibility ! !WMalFunction subclass: #WMalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalAdd commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function + in MAL.!!WMalAdd methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:39'!call: args	"Add args together. TODO: type errors."	| total |	total := 0.	args do: [ :arg | total := total + arg value ].	^ WMalInteger withValue: total! !WMalType subclass: #WMalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!WMalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:17'!print	^ self value asString! !WMalType subclass: #WMalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalList commentStamp: 'WilfredHughes 9/26/2017 19:27' prior: 0!I represent a list value in MAL.!!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:50'!evalIn: env	| evalledItems func |	"Empty list evaluates to itself"	self value ifEmpty: [ ^ self ].	"Evaluate all the items in the list, then call the first arg with the rest."	evalledItems := self value collect: [ :item | item evalIn: env ].	func := evalledItems first.	^ func call: evalledItems allButFirst! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:49'!print   | inner |inner := ' ' join: (value collect: #print).^ '(', inner, ')'! !WMalType subclass: #WMalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!WMalNil methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:38'!print	^ 'nil'! !WMalFunction subclass: #WMalSubtract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSubtract commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function - in MAL.!!WMalSubtract methodsFor: 'accessing' stamp: 'WilfredHughes 11/6/2017 00:04'!call: args	"Subtract args. TODO: type errors."	| total |	args ifEmpty: [ ^ WMalInteger withValue: 0 ].	args size = 1		ifTrue: [ ^ WMalInteger withValue: args first value negated ].	total := args first value.	args allButFirst do: [ :arg | total := total - arg value ].	^ WMalInteger withValue: total! !WMalType subclass: #WMalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:11'!evalIn: env	env at: self value ifPresent: [ :currentValue | ^currentValue ] ifAbsent: [ WMalUnboundSymbol signal: 'Unbound variable: ' , self value ]! !!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:54'!print	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalSymbol class	instanceVariableNames: ''!!WMalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !WMalError subclass: #WMalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!WMalTokenizer initialize!TestCase subclass: #WMalBoolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalBoolTest commentStamp: 'WilfredHughes 11/1/2017 00:21' prior: 0!I test methods on WMalBool objects.!!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:21'!testPrint| val|val := WMalBool withValue: false.self assert: (val print) equals: 'false'.! !!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 22:59'!testEvalIn	| val |	val := WMalBool withValue: false.	self assert: (val evalIn: nil) equals: val! !TestCase subclass: #WMalIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalIntegerTest commentStamp: '<historical>' prior: 0!A WMalIntegerTest is a test class for testing the behavior of WMalInteger!!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:20'!testPrint	"Ensure we can convert to a printable representation."	| int |	int := WMalInteger withValue: 123.	self assert: int print equals: '123'! !!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 18:56'!testEquality	"Ensure = works as expected."	| int1a int1b int2 |	int1a := WMalInteger withValue: 1.	int1b := WMalInteger withValue: 1.	int2 := WMalInteger withValue: 2.	self assert: int1a = int1b.	self assert: int1a ~= int2! !TestCase subclass: #WMalListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalListTest commentStamp: 'WilfredHughes 11/2/2017 08:46' prior: 0!Testing methods on WMalList.!!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:48'!testPrint	| val first second items |	first := WMalInteger withValue: 1.	second := WMalInteger withValue: 2.	items := OrderedCollection with: first with: second.	val := WMalList withValue: items.		self assert: val print equals: '(1 2)'! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:42'!testEval	"Evaluate a list."	| val env |	val := WMal read: '(+ 1 (+ 2 3))'.	env := Dictionary new		at: '+' put: WMalAdd new;		yourself.	self assert: (val evalIn: env) equals: (WMalInteger withValue: 6)! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:19'!testEvalEmpty"Empty list should evaluate to itself."	| val items |	items := OrderedCollection new.	val := WMalList withValue: items.	self assert: (val evalIn: nil) equals: val! !TestCase subclass: #WMalNilTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:38'!testPrint	"Ensure we can convert to a printable representation."	| nilValue |	nilValue := WMalNil new.	self assert: nilValue print equals: 'nil'! !!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:14'!testEvalIn	| nilValue |	nilValue := WMalNil new.	self assert: (nilValue evalIn: nil) equals: nilValue! !TestCase subclass: #WMalReaderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalReaderTest commentStamp: '<historical>' prior: 0!A WMalReaderTest is a test class for testing the behavior of WMalReader!!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 19:05'!testReadAtom	| parsed expected stream |	stream := (OrderedCollection with: '123') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalInteger withValue: 123.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/4/2017 08:34'!testReadAtomSymbol	| parsed expected stream |	stream := (OrderedCollection with: 'abc') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalSymbol withValue: 'abc'.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:12'!testReadAtomFalse	| parsed expected stream |	stream := (OrderedCollection with: 'false') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: false.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:46'!testReadAtomTrue	| parsed expected stream |	stream := (OrderedCollection with: 'true') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: true.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:42'!testReadAtomNil	| parsed expected stream |	stream := (OrderedCollection with: 'nil') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalNil new.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:36'!testReadString	| parsed |	parsed := WMalReader readString: '123'.	self assert: parsed equals: (WMalInteger withValue: 123)! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnopened"todo: We don't consider foo) to be a syntax error because we only read one form."	self should: [WMalReader readString: ')'] raise: WMalSyntaxError.! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/26/2017 19:39'!testReadForm	| parsed expectedItems |	parsed := WMalReader readString: '(1 2)'.	self assert: parsed class equals: WMalList.	expectedItems := OrderedCollection with: (WMalInteger withValue: 1) with: (WMalInteger withValue: 2).	self assert: parsed value equals: expectedItems! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnclosed	self should: [ WMalReader readString: '(' ] raise: WMalSyntaxError! !TestCase subclass: #WMalSubtractTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalSubtractTest commentStamp: '<historical>' prior: 0!A WMalSubtractTest is a test class for testing the behavior of WMalSubtract!!WMalSubtractTest methodsFor: 'tests' stamp: 'WilfredHughes 11/6/2017 00:00'!testCall	| sexp |	sexp := WMal read: '(- 3 2)'.	self		assert: (sexp evalIn: WMal defaultEnv)		equals: (WMalInteger		withValue: 1)! !TestCase subclass: #WMalSymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:53'!testPrint	"Ensure we can convert to a printable representation."	| symValue |	symValue := WMalSymbol withValue: 'foo'.	self assert: symValue print equals: 'foo'! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:10'!testEvalIn	"Test that we lookup values in the environment."	| fooSym env one |	fooSym := WMalSymbol withValue: 'foo'.	one := WMalInteger withValue: 1.	env := Dictionary new		at: 'foo' put: one;		yourself.	self assert: (fooSym evalIn: env) equals: one! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:03'!testEvalInUnbound	"Test that we error on unbound symbols."	| fooSym env |	fooSym := WMalSymbol withValue: 'foo'.	env := Dictionary new.	self should: [ fooSym evalIn: env ] raise: WMalUnboundSymbol ! !TestCase subclass: #WMalTokenizerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalTokenizerTest commentStamp: 'WilfredHughes 8/27/2017 17:23' prior: 0!A WMalTokenizerTest is a test class for testing the behavior of WMalTokenizer.!!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 8/27/2017 17:27'!testTokenize	| instance tokens expected |	instance := WMalTokenizer withSource: ' foo bar'.	tokens := instance tokenize.	expected := OrderedCollection with: 'foo' with: 'bar'.	self assert: tokens equals: expected! !