Object subclass: #WMal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMal commentStamp: 'WilfredHughes 8/22/2017 00:27' prior: 0!I am a Make-A-Lisp (MAL) interpreter.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMal class	instanceVariableNames: ''!!WMal class methodsFor: 'printing' stamp: 'WilfredHughes 11/5/2017 22:44'!print: aValue	^ aValue print! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!eval: aForm in: env	^ aForm! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:49'!evalAst: aForm in: env	^ aForm! !!WMal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 11/5/2017 22:45'!read: aString	^ WMalReader readString: aString! !Error subclass: #WMalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!WMalError subclass: #WMalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!Object subclass: #WMalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalReader commentStamp: 'WilfredHughes 11/3/2017 08:02' prior: 0!I convert MAL source code to an AST instance of WMalType.To get started, use #readString:WMalReader readString: '(+ 1 2').!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalReader class	instanceVariableNames: ''!!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/3/2017 09:01'!readAtom: aStream	"Parse a single mal type."	| token |	token := aStream next.	token ifNil: [ WMalSyntaxError signal: 'Missing )' ].	token = ')'		ifTrue: [ WMalSyntaxError signal: 'Unexpected )' ].	token isAllDigits		ifTrue: [ ^ WMalInteger withValue: token asInteger ].	token = 'nil'		ifTrue: [ ^ WMalNil new ].	token = 'true'		ifTrue: [ ^ WMalBool withValue: true ].	token = 'false'		ifTrue: [ ^ WMalBool withValue: false ].	^ WMalSymbol withValue: token! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:36'!readForm: aTokenStream	| current |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream ]		ifFalse: [ ^ self readAtom: aTokenStream ]! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:41'!readString: aString	"Lex and parse a string of MAL source code."	| parsed tokens |	parsed := OrderedCollection new.	tokens := (WMalTokenizer withSource: aString) tokenize.	^self readForm: tokens readStream! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 10/30/2017 08:32'!readList: aTokenStream	| items current finished |	items := OrderedCollection new.	finished := false.	[ finished ]		whileFalse: [ current := aTokenStream peek.			Transcript				show: current;				cr.			current = ')'				ifTrue: [ finished := true. aTokenStream next. ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	self assert: current = ')' description: 'Unclosed ('.	^ WMalList withValue: items! !WMalError subclass: #WMalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #WMalTokenizer	instanceVariableNames: 'source'	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'WMal'!!WMalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!!WMalTokenizer methodsFor: 'accessing' stamp: 'WilfredHughes 8/22/2017 19:35'!source: aString	source := aString! !!WMalTokenizer methodsFor: 'instance creation' stamp: 'WilfredHughes 10/30/2017 08:20'!tokenize	"Return a collection of all the tokens in our string."	| matcher result |	matcher := RxMatcher forString: TokenPattern.	result := OrderedCollection new.	matcher		matchesOnStream: source readStream		do: [ :s :m | result add: (m subexpression: 2) ].	^ result reject: [ :str | str isEmpty ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalTokenizer class	instanceVariableNames: 'source'!!WMalTokenizer class methodsFor: 'initialization' stamp: 'WilfredHughes 8/22/2017 19:18'!initialize	"This isn't exactly the same as the MAL docs.We are forced to treat [ and ] separately due to syntax limitationsin the regex engine."	TokenPattern := '[\s,]*(~@|\[|[]{}()''`~^@]|"(\\.|[^\\"])*"|;.*|(\[|\]|[^\s{}(''"`,;)])*)'! !!WMalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 8/25/2017 08:31'!withSource: aString	"Initialise with source code specified."	| instance |	instance := self new.	instance source: aString.	^ instance! !Object subclass: #WMalType	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalType commentStamp: 'WilfredHughes 8/27/2017 18:04' prior: 0!I am the base class for all MAL types.!!WMalType methodsFor: 'comparing' stamp: 'WilfredHughes 9/1/2017 19:13'!= anObject	self class = anObject class		ifTrue: [ ^ value = (anObject value) ]		ifFalse: [ ^ false ]! !!WMalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value: anInteger	value := anInteger.	^self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:13'!evalIn: env 	^ self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:33'!call: args"Try to call this value as a function."	WMalNotCallable signal: 'Not a function: ' , self print! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:14'!print	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalType class	instanceVariableNames: ''!!WMalType class methodsFor: 'initialization' stamp: 'WilfredHughes 9/4/2017 08:30'!withValue: aNumber	| instance |	instance := self new.	instance value: aNumber.	^ instance! !WMalType subclass: #WMalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!WMalBool methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:22'!print	^ self value asString! !WMalType subclass: #WMalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalFunction commentStamp: 'WilfredHughes 11/5/2017 23:29' prior: 0!I represent callable values in MAL. Currently just built-in functions.!!WMalFunction methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:33'!call: args	self subclassResponsibility ! !WMalFunction subclass: #WMalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!WMalType subclass: #WMalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!WMalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:17'!print	^ self value asString! !WMalType subclass: #WMalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalList commentStamp: 'WilfredHughes 9/26/2017 19:27' prior: 0!I represent a list value in MAL.!!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:24'!evalIn: env	self value size == 0 ifTrue: [ 		^ self		 ]! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:49'!print   | inner |inner := ' ' join: (value collect: #print).^ '(', inner, ')'! !WMalType subclass: #WMalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!WMalNil methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:38'!print	^ 'nil'! !WMalType subclass: #WMalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:11'!evalIn: env	env at: self value ifPresent: [ :currentValue | ^currentValue ] ifAbsent: [ WMalUnboundSymbol signal: 'Unbound variable: ' , self value ]! !!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:54'!print	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalSymbol class	instanceVariableNames: ''!!WMalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !WMalError subclass: #WMalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!WMalTokenizer initialize!TestCase subclass: #WMalBoolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalBoolTest commentStamp: 'WilfredHughes 11/1/2017 00:21' prior: 0!I test methods on WMalBool objects.!!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:21'!testPrint| val|val := WMalBool withValue: false.self assert: (val print) equals: 'false'.! !!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 22:59'!testEvalIn	| val |	val := WMalBool withValue: false.	self assert: (val evalIn: nil) equals: val! !TestCase subclass: #WMalIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalIntegerTest commentStamp: '<historical>' prior: 0!A WMalIntegerTest is a test class for testing the behavior of WMalInteger!!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:20'!testPrint	"Ensure we can convert to a printable representation."	| int |	int := WMalInteger withValue: 123.	self assert: int print equals: '123'! !!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 18:56'!testEquality	"Ensure = works as expected."	| int1a int1b int2 |	int1a := WMalInteger withValue: 1.	int1b := WMalInteger withValue: 1.	int2 := WMalInteger withValue: 2.	self assert: int1a = int1b.	self assert: int1a ~= int2! !TestCase subclass: #WMalListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalListTest commentStamp: 'WilfredHughes 11/2/2017 08:46' prior: 0!Testing methods on WMalList.!!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:48'!testPrint	| val first second items |	first := WMalInteger withValue: 1.	second := WMalInteger withValue: 2.	items := OrderedCollection with: first with: second.	val := WMalList withValue: items.		self assert: val print equals: '(1 2)'! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:19'!testEvalEmpty"Empty list should evaluate to itself."	| val items |	items := OrderedCollection new.	val := WMalList withValue: items.	self assert: (val evalIn: nil) equals: val! !TestCase subclass: #WMalNilTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:38'!testPrint	"Ensure we can convert to a printable representation."	| nilValue |	nilValue := WMalNil new.	self assert: nilValue print equals: 'nil'! !!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:14'!testEvalIn	| nilValue |	nilValue := WMalNil new.	self assert: (nilValue evalIn: nil) equals: nilValue! !TestCase subclass: #WMalReaderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalReaderTest commentStamp: '<historical>' prior: 0!A WMalReaderTest is a test class for testing the behavior of WMalReader!!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 19:05'!testReadAtom	| parsed expected stream |	stream := (OrderedCollection with: '123') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalInteger withValue: 123.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/4/2017 08:34'!testReadAtomSymbol	| parsed expected stream |	stream := (OrderedCollection with: 'abc') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalSymbol withValue: 'abc'.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:12'!testReadAtomFalse	| parsed expected stream |	stream := (OrderedCollection with: 'false') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: false.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:46'!testReadAtomTrue	| parsed expected stream |	stream := (OrderedCollection with: 'true') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: true.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:42'!testReadAtomNil	| parsed expected stream |	stream := (OrderedCollection with: 'nil') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalNil new.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:36'!testReadString	| parsed |	parsed := WMalReader readString: '123'.	self assert: parsed equals: (WMalInteger withValue: 123)! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnopened"todo: We don't consider foo) to be a syntax error because we only read one form."	self should: [WMalReader readString: ')'] raise: WMalSyntaxError.! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/26/2017 19:39'!testReadForm	| parsed expectedItems |	parsed := WMalReader readString: '(1 2)'.	self assert: parsed class equals: WMalList.	expectedItems := OrderedCollection with: (WMalInteger withValue: 1) with: (WMalInteger withValue: 2).	self assert: parsed value equals: expectedItems! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnclosed	self should: [ WMalReader readString: '(' ] raise: WMalSyntaxError! !TestCase subclass: #WMalSymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:53'!testPrint	"Ensure we can convert to a printable representation."	| symValue |	symValue := WMalSymbol withValue: 'foo'.	self assert: symValue print equals: 'foo'! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:10'!testEvalIn	"Test that we lookup values in the environment."	| fooSym env one |	fooSym := WMalSymbol withValue: 'foo'.	one := WMalInteger withValue: 1.	env := Dictionary new		at: 'foo' put: one;		yourself.	self assert: (fooSym evalIn: env) equals: one! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:03'!testEvalInUnbound	"Test that we error on unbound symbols."	| fooSym env |	fooSym := WMalSymbol withValue: 'foo'.	env := Dictionary new.	self should: [ fooSym evalIn: env ] raise: WMalUnboundSymbol ! !TestCase subclass: #WMalTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalTest commentStamp: '<historical>' prior: 0!A WMalTest is a test class for testing the behavior of WMal!!WMalTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 22:54'!testEvalAstSymbol	| foo |	self should: [ WMal evalAst: foo in: nil ] raise: WMalUnboundSymbol! !!WMalTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 22:50'!testFoo^ nil! !TestCase subclass: #WMalTokenizerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalTokenizerTest commentStamp: 'WilfredHughes 8/27/2017 17:23' prior: 0!A WMalTokenizerTest is a test class for testing the behavior of WMalTokenizer.!!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 8/27/2017 17:27'!testTokenize	| instance tokens expected |	instance := WMalTokenizer withSource: ' foo bar'.	tokens := instance tokenize.	expected := OrderedCollection with: 'foo' with: 'bar'.	self assert: tokens equals: expected! !