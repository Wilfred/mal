Object subclass: #LinkedDictionary	instanceVariableNames: 'items next'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!LinkedDictionary commentStamp: 'WilfredHughes 11/6/2017 19:12' prior: 0!I represent a Dictionary that can defer to other dictionaries if a key is not found.I'm intended to be used to model environments in MAL.!!LinkedDictionary methodsFor: 'setter' stamp: 'WilfredHughes 11/6/2017 19:17'!items: aDictionary 	items := aDictionary! !!LinkedDictionary methodsFor: 'setter' stamp: 'WilfredHughes 11/9/2017 19:20'!next: aLinkedDictionary 	next := aLinkedDictionary! !!LinkedDictionary methodsFor: 'setter' stamp: 'WilfredHughes 3/13/2018 08:52'!at: key put: value	"Insert this key at this level"	items at: key put: value! !!LinkedDictionary methodsFor: 'setter' stamp: 'WilfredHughes 3/25/2018 12:15'!at: key    ^ self at: key ifAbsent: [ KeyNotFound signalFor: key ]! !!LinkedDictionary methodsFor: 'setter' stamp: 'WilfredHughes 11/9/2017 19:24'!at: key ifAbsent: aBlock^ items at: key ifAbsent: [ next ifNotNil: [ ^ next at: key ifAbsent: aBlock ] ifNil: [ aBlock value ] ]  ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LinkedDictionary class	instanceVariableNames: ''!!LinkedDictionary class methodsFor: 'instance creation' stamp: 'WilfredHughes 11/9/2017 19:17'!withNext: env	^ self		new		next: env;		yourself! !!LinkedDictionary class methodsFor: 'instance creation' stamp: 'WilfredHughes 3/21/2018 08:36'!new	^ super new		items: IdentityDictionary  new;		yourself! !Object subclass: #WMal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMal commentStamp: 'WilfredHughes 3/13/2018 08:43' prior: 0!I am a Make-A-Lisp (MAL) interpreter.Example usage:Mal demo.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMal class	instanceVariableNames: ''!!WMal class methodsFor: 'printing' stamp: 'WilfredHughes 11/5/2017 22:44'!print: aValue	^ aValue print! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:52'!rep: aString^ self rep: aString in: (self defaultEnv )! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 23:56'!eval: aForm in: env	^ aForm evalIn: env! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 3/13/2018 08:48'!defaultEnv	^ Dictionary new		at: '+' put: WMalAdd new;		at: '-' put: WMalSubtract new;		at: '*' put: WMalMultiply new;		at: '/' put: WMalDivide new;		yourself! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 3/13/2018 08:48'!demo	| val env |	val := WMal read: '(/ (+ 5 6) 2)'.	env := WMal defaultEnv.	^ val evalIn: env! !!WMal class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/5/2017 22:47'!rep: aString in: env	^ self print: (self eval: (self read: aString) in: env)! !!WMal class methodsFor: 'meta-object-protocol' stamp: 'WilfredHughes 11/5/2017 22:45'!read: aString	^ WMalReader readString: aString! !Error subclass: #WMalError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I am the base class for all exceptions in MAL.!WMalError subclass: #WMalNotCallable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalNotCallable commentStamp: 'WilfredHughes 11/5/2017 23:28' prior: 0!The error when a MAL program tries to call something that isn't a function.!Object subclass: #WMalReader	instanceVariableNames: 'tokens index'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalReader commentStamp: 'WilfredHughes 11/3/2017 08:02' prior: 0!I convert MAL source code to an AST instance of WMalType.To get started, use #readString:WMalReader readString: '(+ 1 2').!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalReader class	instanceVariableNames: ''!!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 11/3/2017 09:01'!readAtom: aStream	"Parse a single mal type."	| token |	token := aStream next.	token ifNil: [ WMalSyntaxError signal: 'Missing )' ].	token = ')'		ifTrue: [ WMalSyntaxError signal: 'Unexpected )' ].	token isAllDigits		ifTrue: [ ^ WMalInteger withValue: token asInteger ].	token = 'nil'		ifTrue: [ ^ WMalNil new ].	token = 'true'		ifTrue: [ ^ WMalBool withValue: true ].	token = 'false'		ifTrue: [ ^ WMalBool withValue: false ].	^ WMalSymbol withValue: token! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:36'!readForm: aTokenStream	| current |	current := aTokenStream peek.	current = '('		ifTrue: [ aTokenStream next.			^ self readList: aTokenStream ]		ifFalse: [ ^ self readAtom: aTokenStream ]! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 9/26/2017 19:41'!readString: aString	"Lex and parse a string of MAL source code."	| parsed tokens |	parsed := OrderedCollection new.	tokens := (WMalTokenizer withSource: aString) tokenize.	^self readForm: tokens readStream! !!WMalReader class methodsFor: 'as yet unclassified' stamp: 'WilfredHughes 10/30/2017 08:32'!readList: aTokenStream	| items current finished |	items := OrderedCollection new.	finished := false.	[ finished ]		whileFalse: [ current := aTokenStream peek.			Transcript				show: current;				cr.			current = ')'				ifTrue: [ finished := true. aTokenStream next. ]				ifFalse: [ items add: (self readForm: aTokenStream) ] ].	self assert: current = ')' description: 'Unclosed ('.	^ WMalList withValue: items! !WMalError subclass: #WMalSyntaxError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSyntaxError commentStamp: 'WilfredHughes 11/3/2017 08:41' prior: 0!I represent syntax errors in MAL.!Object subclass: #WMalTokenizer	instanceVariableNames: 'source'	classVariableNames: 'TokenPattern'	poolDictionaries: ''	category: 'WMal'!!WMalTokenizer commentStamp: 'WilfredHughes 8/22/2017 00:41' prior: 0!I parse MAL tokens from a string.!!WMalTokenizer methodsFor: 'accessing' stamp: 'WilfredHughes 8/22/2017 19:35'!source: aString	source := aString! !!WMalTokenizer methodsFor: 'instance creation' stamp: 'WilfredHughes 10/30/2017 08:20'!tokenize	"Return a collection of all the tokens in our string."	| matcher result |	matcher := RxMatcher forString: TokenPattern.	result := OrderedCollection new.	matcher		matchesOnStream: source readStream		do: [ :s :m | result add: (m subexpression: 2) ].	^ result reject: [ :str | str isEmpty ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalTokenizer class	instanceVariableNames: 'source'!!WMalTokenizer class methodsFor: 'initialization' stamp: 'WilfredHughes 8/22/2017 19:18'!initialize	"This isn't exactly the same as the MAL docs.We are forced to treat [ and ] separately due to syntax limitationsin the regex engine."	TokenPattern := '[\s,]*(~@|\[|[]{}()''`~^@]|"(\\.|[^\\"])*"|;.*|(\[|\]|[^\s{}(''"`,;)])*)'! !!WMalTokenizer class methodsFor: 'instance creation' stamp: 'WilfredHughes 8/25/2017 08:31'!withSource: aString	"Initialise with source code specified."	| instance |	instance := self new.	instance source: aString.	^ instance! !Object subclass: #WMalType	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalType commentStamp: 'WilfredHughes 8/27/2017 18:04' prior: 0!I am the base class for all MAL types.!!WMalType methodsFor: 'comparing' stamp: 'WilfredHughes 9/1/2017 19:13'!= anObject	self class = anObject class		ifTrue: [ ^ value = (anObject value) ]		ifFalse: [ ^ false ]! !!WMalType methodsFor: 'printing' stamp: 'WilfredHughes 9/1/2017 19:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: value printString ;		nextPutAll: ')'! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value: anInteger	value := anInteger.	^self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 9/1/2017 19:16'!value^ value! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:33'!call: args"Try to call this value as a function."	WMalNotCallable signal: 'Not a function: ' , self print! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 3/13/2018 08:40'!evalIn: env"Default behaviour is types evaluate to themselves."	^ self! !!WMalType methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:14'!print	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalType class	instanceVariableNames: ''!!WMalType class methodsFor: 'initialization' stamp: 'WilfredHughes 9/4/2017 08:30'!withValue: aNumber	| instance |	instance := self new.	instance value: aNumber.	^ instance! !WMalType subclass: #WMalBool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalBool commentStamp: 'WilfredHughes 10/30/2017 08:45' prior: 0!I represent boolean values (true and false) in MAL.!!WMalBool methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:22'!print	^ self value asString! !WMalType subclass: #WMalFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalFunction commentStamp: 'WilfredHughes 11/5/2017 23:29' prior: 0!I represent callable values in MAL. Currently just built-in functions.!!WMalFunction methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:33'!call: args	self subclassResponsibility ! !WMalFunction subclass: #WMalAdd	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalAdd commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function + in MAL.!!WMalAdd methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:39'!call: args	"Add args together. TODO: type errors."	| total |	total := 0.	args do: [ :arg | total := total + arg value ].	^ WMalInteger withValue: total! !WMalFunction subclass: #WMalDivide	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalDivide commentStamp: 'WilfredHughes 11/6/2017 19:01' prior: 0!The built-in function / in MAL.!!WMalDivide methodsFor: 'accessing' stamp: 'WilfredHughes 11/6/2017 19:06'!call: args	"Divide args together. TODO: type errors, arity errors"	| result |	result := args first value.	args allButFirstDo: [ :arg | result := result // arg value ].	^ WMalInteger withValue: result! !WMalType subclass: #WMalInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalInteger commentStamp: 'WilfredHughes 8/28/2017 00:37' prior: 0!I represent whole numbers in MAL.!!WMalInteger methodsFor: 'accessing' stamp: 'WilfredHughes 11/1/2017 00:17'!print	^ self value asString! !WMalType subclass: #WMalKeyword	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalKeyword commentStamp: 'WilfredHughes 3/13/2018 08:30' prior: 0!I represent keywords  in MAL.Keywords are symbols that start with :, e.g. :foo.Keywords evaluate to themselves.!!WMalKeyword methodsFor: 'accessing' stamp: 'WilfredHughes 3/13/2018 08:29'!print	^ ':', value! !WMalType subclass: #WMalList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalList commentStamp: 'WilfredHughes 9/26/2017 19:27' prior: 0!I represent a list value in MAL.!!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:50'!evalIn: env	| evalledItems func |	"Empty list evaluates to itself"	self value ifEmpty: [ ^ self ].	"Evaluate all the items in the list, then call the first arg with the rest."	evalledItems := self value collect: [ :item | item evalIn: env ].	func := evalledItems first.	^ func call: evalledItems allButFirst! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 9/26/2017 19:38'!size	^ value size! !!WMalList methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:49'!print   | inner |inner := ' ' join: (value collect: #print).^ '(', inner, ')'! !WMalFunction subclass: #WMalMultiply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalMultiply commentStamp: 'WilfredHughes 11/6/2017 18:57' prior: 0!The built-in function * in MAL.!!WMalMultiply methodsFor: 'accessing' stamp: 'WilfredHughes 11/6/2017 18:59'!call: args	"Multiply args together. TODO: type errors."	| total |	total := 1.	args do: [ :arg | total := total * arg value ].	^ WMalInteger withValue: total! !WMalType subclass: #WMalNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalNil commentStamp: 'WilfredHughes 10/30/2017 08:40' prior: 0!I represent the nil value in MAL.!!WMalNil methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:38'!print	^ 'nil'! !WMalFunction subclass: #WMalSubtract	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSubtract commentStamp: 'WilfredHughes 11/6/2017 00:04' prior: 0!The built-in function - in MAL.!!WMalSubtract methodsFor: 'accessing' stamp: 'WilfredHughes 11/6/2017 00:04'!call: args	"Subtract args. TODO: type errors."	| total |	args ifEmpty: [ ^ WMalInteger withValue: 0 ].	args size = 1		ifTrue: [ ^ WMalInteger withValue: args first value negated ].	total := args first value.	args allButFirst do: [ :arg | total := total - arg value ].	^ WMalInteger withValue: total! !WMalType subclass: #WMalSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalSymbol commentStamp: 'WilfredHughes 9/5/2017 19:09' prior: 0!I represent symbols in MAL.I use Smalltalk strings to represent  a MAL symbol rather than Smalltalk symbols. This isto avoid issues with MAL symbols that aren't valid Smalltalk symbols.Two symbols are equal if they have the same string value.!!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/5/2017 23:11'!evalIn: env	env at: self value ifPresent: [ :currentValue | ^currentValue ] ifAbsent: [ WMalUnboundSymbol signal: 'Unbound variable: ' , self value ]! !!WMalSymbol methodsFor: 'accessing' stamp: 'WilfredHughes 11/2/2017 08:54'!print	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WMalSymbol class	instanceVariableNames: ''!!WMalSymbol class methodsFor: 'initialize-release' stamp: 'WilfredHughes 9/1/2017 19:10'!withValue: aString	| instance |	instance := self new.	^instance value: aString.! !WMalError subclass: #WMalUnboundSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal'!!WMalUnboundSymbol commentStamp: 'WilfredHughes 11/5/2017 22:55' prior: 0!Error raised when we attempt to evaluate a MAL symbol that isn't defined.!WMalTokenizer initialize!TestCase subclass: #LinkedDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!LinkedDictionaryTest commentStamp: '<historical>' prior: 0!A LinkedDictionaryTest is a test class for testing the behavior of LinkedDictionary!!LinkedDictionaryTest methodsFor: 'tests-setter' stamp: 'WilfredHughes 3/25/2018 12:16'!testAtIfAbsent	| dict |	dict := LinkedDictionary new.	dict at: 'foo' put: 123.	self assert: (dict at: 'foo') equals: 123! !TestCase subclass: #WMalBoolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalBoolTest commentStamp: 'WilfredHughes 11/1/2017 00:21' prior: 0!I test methods on WMalBool objects.!!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:21'!testPrint| val|val := WMalBool withValue: false.self assert: (val print) equals: 'false'.! !!WMalBoolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 22:59'!testEvalIn	| val |	val := WMalBool withValue: false.	self assert: (val evalIn: nil) equals: val! !TestCase subclass: #WMalDivideTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalDivideTest commentStamp: '<historical>' prior: 0!A WMalDivideTest is a test class for testing the behavior of WMalDivide!!WMalDivideTest methodsFor: 'tests-accessing' stamp: 'WilfredHughes 11/6/2017 19:06'!testCall	| args |	args := OrderedCollection		with: (WMalInteger withValue: 11)		with: (WMalInteger withValue: 5).	self		assert: (WMalDivide new call: args)		equals: (WMalInteger withValue: 2)! !TestCase subclass: #WMalIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalIntegerTest commentStamp: '<historical>' prior: 0!A WMalIntegerTest is a test class for testing the behavior of WMalInteger!!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:20'!testPrint	"Ensure we can convert to a printable representation."	| int |	int := WMalInteger withValue: 123.	self assert: int print equals: '123'! !!WMalIntegerTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 18:56'!testEquality	"Ensure = works as expected."	| int1a int1b int2 |	int1a := WMalInteger withValue: 1.	int1b := WMalInteger withValue: 1.	int2 := WMalInteger withValue: 2.	self assert: int1a = int1b.	self assert: int1a ~= int2! !TestCase subclass: #WMalKeywordTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalKeywordTest methodsFor: 'tests' stamp: 'WilfredHughes 3/13/2018 08:27'!testPrint	"Ensure we can convert to a printable representation."	| symValue |	symValue := WMalKeyword withValue: 'foo'.	self assert: symValue print equals: ':foo'! !!WMalKeywordTest methodsFor: 'tests' stamp: 'WilfredHughes 3/13/2018 08:32'!testEquality	"Ensure = works as expected."	| k1 k2 |	k1 := WMalKeyword withValue: 'foo'.	k2 := WMalKeyword withValue: 'bar'.	self assert: k1 = k1.	self assert: k1 ~= k2! !TestCase subclass: #WMalListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalListTest commentStamp: 'WilfredHughes 11/2/2017 08:46' prior: 0!Testing methods on WMalList.!!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:48'!testPrint	| val first second items |	first := WMalInteger withValue: 1.	second := WMalInteger withValue: 2.	items := OrderedCollection with: first with: second.	val := WMalList withValue: items.		self assert: val print equals: '(1 2)'! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:42'!testEval	"Evaluate a list."	| val env |	val := WMal read: '(+ 1 (+ 2 3))'.	env := Dictionary new		at: '+' put: WMalAdd new;		yourself.	self assert: (val evalIn: env) equals: (WMalInteger withValue: 6)! !!WMalListTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:19'!testEvalEmpty"Empty list should evaluate to itself."	| val items |	items := OrderedCollection new.	val := WMalList withValue: items.	self assert: (val evalIn: nil) equals: val! !TestCase subclass: #WMalMultiplyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalMultiplyTest commentStamp: '<historical>' prior: 0!A WMalMultiplyTest is a test class for testing the behavior of WMalMultiply!!WMalMultiplyTest methodsFor: 'tests' stamp: 'WilfredHughes 11/6/2017 18:59'!testCall| args |args := OrderedCollection with: (WMalInteger withValue: 2) with: (WMalInteger withValue: 3).self assert: (WMalMultiply new call: args) equals: (WMalInteger withValue: 6)! !TestCase subclass: #WMalNilTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:38'!testPrint	"Ensure we can convert to a printable representation."	| nilValue |	nilValue := WMalNil new.	self assert: nilValue print equals: 'nil'! !!WMalNilTest methodsFor: 'tests' stamp: 'WilfredHughes 3/13/2018 11:36'!testEvalIn	| nilValue |	nilValue := WMalNil new.	self assert: (nilValue evalIn: nil) equals: nilValue! !TestCase subclass: #WMalReaderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalReaderTest commentStamp: '<historical>' prior: 0!A WMalReaderTest is a test class for testing the behavior of WMalReader!!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/1/2017 19:05'!testReadAtom	| parsed expected stream |	stream := (OrderedCollection with: '123') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalInteger withValue: 123.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/4/2017 08:34'!testReadAtomSymbol	| parsed expected stream |	stream := (OrderedCollection with: 'abc') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalSymbol withValue: 'abc'.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/1/2017 00:12'!testReadAtomFalse	| parsed expected stream |	stream := (OrderedCollection with: 'false') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: false.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:46'!testReadAtomTrue	| parsed expected stream |	stream := (OrderedCollection with: 'true') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalBool withValue: true.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:42'!testReadAtomNil	| parsed expected stream |	stream := (OrderedCollection with: 'nil') readStream.	parsed := WMalReader readAtom: stream.	expected := WMalNil new.	self assert: parsed equals: expected! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 10/30/2017 08:36'!testReadString	| parsed |	parsed := WMalReader readString: '123'.	self assert: parsed equals: (WMalInteger withValue: 123)! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnopened"todo: We don't consider foo) to be a syntax error because we only read one form."	self should: [WMalReader readString: ')'] raise: WMalSyntaxError.! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 9/26/2017 19:39'!testReadForm	| parsed expectedItems |	parsed := WMalReader readString: '(1 2)'.	self assert: parsed class equals: WMalList.	expectedItems := OrderedCollection with: (WMalInteger withValue: 1) with: (WMalInteger withValue: 2).	self assert: parsed value equals: expectedItems! !!WMalReaderTest methodsFor: 'tests' stamp: 'WilfredHughes 11/3/2017 08:59'!testReadStringUnclosed	self should: [ WMalReader readString: '(' ] raise: WMalSyntaxError! !TestCase subclass: #WMalSubtractTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalSubtractTest commentStamp: '<historical>' prior: 0!A WMalSubtractTest is a test class for testing the behavior of WMalSubtract!!WMalSubtractTest methodsFor: 'tests' stamp: 'WilfredHughes 11/6/2017 00:00'!testCall	| sexp |	sexp := WMal read: '(- 3 2)'.	self		assert: (sexp evalIn: WMal defaultEnv)		equals: (WMalInteger		withValue: 1)! !TestCase subclass: #WMalSymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/2/2017 08:53'!testPrint	"Ensure we can convert to a printable representation."	| symValue |	symValue := WMalSymbol withValue: 'foo'.	self assert: symValue print equals: 'foo'! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:10'!testEvalIn	"Test that we lookup values in the environment."	| fooSym env one |	fooSym := WMalSymbol withValue: 'foo'.	one := WMalInteger withValue: 1.	env := Dictionary new		at: 'foo' put: one;		yourself.	self assert: (fooSym evalIn: env) equals: one! !!WMalSymbolTest methodsFor: 'tests' stamp: 'WilfredHughes 11/5/2017 23:03'!testEvalInUnbound	"Test that we error on unbound symbols."	| fooSym env |	fooSym := WMalSymbol withValue: 'foo'.	env := Dictionary new.	self should: [ fooSym evalIn: env ] raise: WMalUnboundSymbol ! !TestCase subclass: #WMalTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalTest commentStamp: '<historical>' prior: 0!A WMalTest is a test class for testing the behavior of WMal!!WMalTest methodsFor: 'tests' stamp: 'WilfredHughes 3/25/2018 12:28'!testEvalIn	| val env |	val := WMal read: '(+ (* 2 3) 1)'.	env := WMal defaultEnv.	self assert: (val evalIn: env) equals: (WMalInteger withValue: 7) 		! !TestCase subclass: #WMalTokenizerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'WMal-Tests'!!WMalTokenizerTest commentStamp: 'WilfredHughes 8/27/2017 17:23' prior: 0!A WMalTokenizerTest is a test class for testing the behavior of WMalTokenizer.!!WMalTokenizerTest methodsFor: 'tests' stamp: 'WilfredHughes 8/27/2017 17:27'!testTokenize	| instance tokens expected |	instance := WMalTokenizer withSource: ' foo bar'.	tokens := instance tokenize.	expected := OrderedCollection with: 'foo' with: 'bar'.	self assert: tokens equals: expected! !